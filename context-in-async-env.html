<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
    <meta charset="UTF-8" />
    <title>异步调用中的上下文控制Tornado stack context  - YS.Zou</title>
    <meta name="generator" content="http://txt2tags.org" />
    <meta name="author" content="Yesheng Zou,YS.Zou,邹业盛"/>
</head>

<body class="z" style="color: #333; font-size: 16px; letter-spacing: 0.2em; font-family: 'Microsoft YaHei','WenQuanYi Micro Hei',SimHei,tahoma,sans-serif; -webkit-font-smoothing: antialiased; margin: 0;">
    <div class="content" style="width: 900px; margin: auto; padding: 30px; box-sizing: border-box; position: relative">
        <div class="header">
            <h1 style="text-align: center; font-size: 26px; margin: 0;">异步调用中的上下文控制Tornado stack context </h1>
            <div class="user" style="margin: 20px auto; text-align: center;">
                <span>邹业盛</span>
                <span>2015-09-30 15:14 更新</span>
            </div>
        </div>

<div class="toc">

  <ol style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
  <li style="margin: 10px auto;"><a href="#toc1" style="color: #0184b7; text-decoration: none">面临的问题</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc2" style="color: #0184b7; text-decoration: none">尝试解决</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc3" style="color: #0184b7; text-decoration: none">Python中的上下文对象及with语句</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc4" style="color: #0184b7; text-decoration: none">Tornado中的stack_context相关内容</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc5" style="color: #0184b7; text-decoration: none">总结与比较</a>
  </li>
  </ol>

</div>

<a class="anchor" name="toc1"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">1. 面临的问题</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里说的"异步调用", 在形式上是指那种"调用函数"里, 需要传入一个"回调函数", 然后调用函数马上就返回. 在这种情况下, 回调函数的异常显然与调用函数的异常是不同的, 并且如果不作特殊处理, 回调函数的异常并不会影响调用函数的表现, 比如下例:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988; font-style: italic"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.ioloop</span>
IL <span style="color: #000000; font-weight: bold">=</span> tornado<span style="color: #000000; font-weight: bold">.</span>ioloop<span style="color: #000000; font-weight: bold">.</span>IOLoop<span style="color: #000000; font-weight: bold">.</span>instance()


<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>():
    <span style="color: #000000; font-weight: bold">raise</span> <span style="color: #990000; font-weight: bold">Exception</span>, <span style="color: #dd1144">&#39;in callback&#39;</span>

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">func</span>():
    IL<span style="color: #000000; font-weight: bold">.</span>add_callback(callback)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">out</span>():
    <span style="color: #000000; font-weight: bold">try</span>:
        func()
    <span style="color: #000000; font-weight: bold">except</span>:
        <span style="color: #000000; font-weight: bold">print</span> <span style="color: #dd1144">&#39;ok&#39;</span>

out()
IL<span style="color: #000000; font-weight: bold">.</span>start()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的代码中, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback</code> 抛出的异常并没有影响到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 函数的表现, 于是我们看不到 <em style="color: #d75100; font-style: normal;">ok</em> 的输出.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
但是在实践当中, 因为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback</code> 的调用, 间接地是由 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 造成的, 通常我们希望的一个结果是, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback</code> 抛出的异常, 应该就像是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 抛出的异常一样, 触发对应的异常处理, 输出 <em style="color: #d75100; font-style: normal;">ok</em> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
注意, 这里对异常的行为, 我们只说 <strong style="color: red; font-weight: normal;">像</strong> <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 抛出的, 或者说, 一个非 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 抛出的异常, 与一个就是由 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 抛出的异常, 它们会造成相同的结果, 这是本质的问题.
</p>

<a class="anchor" name="toc2"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">2. 尝试解决</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
为了达到" <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback</code> 抛出的异常, 就像是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 抛出的一样 " , 这个目的, 我们最直观地会想到这样处理代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>():
    <span style="color: #000000; font-weight: bold">try</span>:
        <span style="color: #000000; font-weight: bold">raise</span> <span style="color: #990000; font-weight: bold">Exception</span>, <span style="color: #dd1144">&#39;in callback&#39;</span>
    <span style="color: #000000; font-weight: bold">except</span>:
        <span style="color: #000000; font-weight: bold">print</span> <span style="color: #dd1144">&#39;ok&#39;</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
或者这样:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">like_other</span>(func):
    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">wrapper</span>(<span style="color: #000000; font-weight: bold">*</span>args, <span style="color: #000000; font-weight: bold">**</span>karg):
        <span style="color: #000000; font-weight: bold">try</span>:
            func(<span style="color: #000000; font-weight: bold">*</span>args, <span style="color: #000000; font-weight: bold">**</span>kargs)
        <span style="color: #000000; font-weight: bold">except</span>:
            <span style="color: #000000; font-weight: bold">print</span> <span style="color: #dd1144">&#39;ok&#39;</span>
    <span style="color: #000000; font-weight: bold">return</span> wrapper

IL<span style="color: #000000; font-weight: bold">.</span>add_callback(like_other(callback))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
好吧, 从现象上我不能说这样做不对, 但是逻辑上, 这种做法只能说是"碰巧"一样了. 顺着这个思路, 我们很容易想到这样的"正确"代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>():
    <span style="color: #000000; font-weight: bold">raise</span> <span style="color: #990000; font-weight: bold">Exception</span>, <span style="color: #dd1144">&#39;in callback&#39;</span>

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">func</span>():
    IL<span style="color: #000000; font-weight: bold">.</span>add_callback(<span style="color: #000000; font-weight: bold">lambda</span>: env(callback))

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">env</span>(func):
    <span style="color: #000000; font-weight: bold">try</span>:
        func()
    <span style="color: #000000; font-weight: bold">except</span>:
        <span style="color: #000000; font-weight: bold">print</span> <span style="color: #dd1144">&#39;ok&#39;</span>

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">out</span>():
    env(func)

out()
IL<span style="color: #000000; font-weight: bold">.</span>start()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
我们把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback</code> 这两个函数都埋到同样的坑里, 这样它们抛出的异常就可以保证有着同样的表现.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样做当然没有问题, 除了代码逻辑上的一个缺陷 -- <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 需要知道它的调用者, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">out</code> 中的细节, 即 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 要知道 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">out</code> 在调用它时挖了一个叫 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">env</code> 的坑. 这个问题就大了, 而且很显然地, 调用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 的地方可能有许多, 除了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">env</code> 它们还使用着各种不同的坑. 所以在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">func</code> 中写死了 <em style="color: #d75100; font-style: normal;">env</em> 这点必须得到改进. 比如引入一个中间的容器:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>():
    <span style="color: #000000; font-weight: bold">raise</span> <span style="color: #990000; font-weight: bold">Exception</span>, <span style="color: #dd1144">&#39;in callback&#39;</span>

HOLE <span style="color: #000000; font-weight: bold">=</span> {}

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">func</span>():
    IL<span style="color: #000000; font-weight: bold">.</span>add_callback(<span style="color: #000000; font-weight: bold">lambda</span>: HOLE[<span style="color: #dd1144">&#39;&#39;</span>](callback))


<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">env</span>(func):
    <span style="color: #000000; font-weight: bold">try</span>:
        func()
    <span style="color: #000000; font-weight: bold">except</span>:
        <span style="color: #000000; font-weight: bold">print</span> <span style="color: #dd1144">&#39;ok&#39;</span>

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">out</span>():
    HOLE<span style="color: #000000; font-weight: bold">.</span>setdefault(<span style="color: #dd1144">&#39;&#39;</span>, env)(func)

out()
IL<span style="color: #000000; font-weight: bold">.</span>start()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
至此, 理想状态下问题似乎得到解决了. 但是实践当中, 情况则会复杂得多, 有不同的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">out</code> , 不同的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">env</code> , 但是基本的处理方式是没有变的, 我们把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">env</code> 抽象成函数执行的"上下文", 把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">HOLE</code> 抽象成一个全局的上下文管理容器, 两者配合, 就可以实现出更通用的结构.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在了解 Tornado 中具体的代码之前, 需要先了解 Python 中的 <em style="color: #d75100; font-style: normal;">Context Manager</em> 上下文对象, 及与之相关的 <em style="color: #d75100; font-style: normal;">with</em> 语句的一些基本知识.
</p>

<a class="anchor" name="toc3"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">3. Python中的上下文对象及with语句</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
定义一个可以被 <em style="color: #d75100; font-style: normal;">with</em> 使用的对象, 只需要实现 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">__enter__</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">__exit__</code> 这两个方法就可以了的:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">class</span> <span style="color: #445588; font-weight: bold">Context</span>(<span style="color: #0086B3">object</span>):

    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">__enter__</span>(<span style="color: #999999">self</span>):
        <span style="color: #000000; font-weight: bold">return</span> <span style="color: #009999">123</span>

    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">__exit__</span>(<span style="color: #999999">self</span>, <span style="color: #0086B3">type</span>, value, traceback):
        <span style="color: #000000; font-weight: bold">return</span> <span style="color: #999999">True</span>


<span style="color: #000000; font-weight: bold">with</span> Context() <span style="color: #000000; font-weight: bold">as</span> i:
    <span style="color: #000000; font-weight: bold">print</span> i
    <span style="color: #000000; font-weight: bold">raise</span> <span style="color: #990000; font-weight: bold">Exception</span>, <span style="color: #009999">1</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">__exit__</code> 方法中接收的参数就是异常的一些信息, 可以从中判断是否抛出了异常. 最后如果返回是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">True</code> , 则忽略异常, 否则会将异常抛出.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
另外, Python 有一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">contextlib</code> 的官方模块, 提供了一些方法, 以便更容易使用上下文对象, 比如一个把生成器转换成上下文对象的装饰器:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">contextlib</span>

<span style="color: #3c5d5d; font-weight: bold">@contextlib.contextmanager</span>
<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">process</span>():
    <span style="color: #000000; font-weight: bold">try</span>:
        <span style="color: #000000; font-weight: bold">yield</span> <span style="color: #009999">123</span>
    <span style="color: #000000; font-weight: bold">except</span>:
        <span style="color: #000000; font-weight: bold">pass</span>

<span style="color: #000000; font-weight: bold">with</span> process() <span style="color: #000000; font-weight: bold">as</span> i:
    <span style="color: #000000; font-weight: bold">print</span> i
    <span style="color: #000000; font-weight: bold">raise</span> <span style="color: #990000; font-weight: bold">Exception</span>, <span style="color: #009999">2</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
生成器中的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">yield</code> 出来的值, 就是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">with</code> 语句的接收值, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">yield</code> 语句的表现就是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">with</code> 结构中语句的表现.
</p>

<a class="anchor" name="toc4"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">4. Tornado中的stack_context相关内容</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
Tornado 中, 我觉得 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack_context.py</code> 是一个同 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">gen.py</code> 一样让人很难一下看明白的东西. 为了简单, 我们从 <em style="color: #d75100; font-style: normal;">1.0.1</em> 和 <em style="color: #d75100; font-style: normal;">1.1.0</em> 这两个比较旧的版本着手, 因为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack_context</code> 的机制是从 <em style="color: #d75100; font-style: normal;">1.1.0</em> 开始加入的, 那时的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack_context.py</code> 内容比现在的少多了.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
看下面的代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988; font-style: italic"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.httpserver</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.ioloop</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.options</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.web</span>

IL <span style="color: #000000; font-weight: bold">=</span> tornado<span style="color: #000000; font-weight: bold">.</span>ioloop<span style="color: #000000; font-weight: bold">.</span>IOLoop<span style="color: #000000; font-weight: bold">.</span>instance()

<span style="color: #000000; font-weight: bold">from</span> <span style="color: #555555">tornado.options</span> <span style="color: #000000; font-weight: bold">import</span> define, options

define(<span style="color: #dd1144">&quot;port&quot;</span>, default<span style="color: #000000; font-weight: bold">=</span><span style="color: #009999">8888</span>, help<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&quot;run on the given port&quot;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #0086B3">int</span>)


<span style="color: #000000; font-weight: bold">class</span> <span style="color: #445588; font-weight: bold">MainHandler</span>(tornado<span style="color: #000000; font-weight: bold">.</span>web<span style="color: #000000; font-weight: bold">.</span>RequestHandler):

    <span style="color: #3c5d5d; font-weight: bold">@tornado.web.asynchronous</span>
    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">get</span>(<span style="color: #999999">self</span>):
        IL<span style="color: #000000; font-weight: bold">.</span>add_callback(<span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>callback)

    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(<span style="color: #999999">self</span>):
        <span style="color: #000000; font-weight: bold">raise</span> <span style="color: #990000; font-weight: bold">Exception</span>
        <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>finish(<span style="color: #dd1144">&quot;Hello, world&quot;</span>)


<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">main</span>():
    tornado<span style="color: #000000; font-weight: bold">.</span>options<span style="color: #000000; font-weight: bold">.</span>parse_command_line()
    application <span style="color: #000000; font-weight: bold">=</span> tornado<span style="color: #000000; font-weight: bold">.</span>web<span style="color: #000000; font-weight: bold">.</span>Application([
        (<span style="color: #dd1144">r&quot;/&quot;</span>, MainHandler),
    ])
    http_server <span style="color: #000000; font-weight: bold">=</span> tornado<span style="color: #000000; font-weight: bold">.</span>httpserver<span style="color: #000000; font-weight: bold">.</span>HTTPServer(application)
    http_server<span style="color: #000000; font-weight: bold">.</span>listen(options<span style="color: #000000; font-weight: bold">.</span>port)
    tornado<span style="color: #000000; font-weight: bold">.</span>ioloop<span style="color: #000000; font-weight: bold">.</span>IOLoop<span style="color: #000000; font-weight: bold">.</span>instance()<span style="color: #000000; font-weight: bold">.</span>start()


<span style="color: #000000; font-weight: bold">if</span> __name__ <span style="color: #000000; font-weight: bold">==</span> <span style="color: #dd1144">&quot;__main__&quot;</span>:
    main()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
最简单的一个应用, 在两个不同版本的 Tornado 下, 实际运行访问当中, 有没有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack_context</code> 结果区别很明显, 有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack_context</code> , 则得到 <em style="color: #d75100; font-style: normal;">500</em> 的响应, 否则一直没有响应.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
实现的细节当中, 有两部分内容, 一是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">web.py</code> 中, 在执行具体的业务函数的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_execute</code> 函数里, 挖了一个上下文管理的坑:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">_execute</span>(<span style="color: #999999">self</span>, transforms, <span style="color: #000000; font-weight: bold">*</span>args, <span style="color: #000000; font-weight: bold">**</span>kwargs):
    <span style="color: #dd1144">&quot;&quot;&quot;Executes this request with the given output transforms.&quot;&quot;&quot;</span>
    <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>_transforms <span style="color: #000000; font-weight: bold">=</span> transforms
    <span style="color: #000000; font-weight: bold">with</span> stack_context<span style="color: #000000; font-weight: bold">.</span>StackContext(<span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>_stack_context):
        <span style="color: #000000; font-weight: bold">...</span> <span style="color: #000000; font-weight: bold">...</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
同时在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">ioloop.py</code> 中, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add_callback</code> 也对传入的回调函数作了上下文有关的包装:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">add_callback</span>(<span style="color: #999999">self</span>, callback):
    <span style="color: #dd1144">&quot;&quot;&quot;Calls the given callback on the next I/O loop iteration.&quot;&quot;&quot;</span>
    <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>_callbacks<span style="color: #000000; font-weight: bold">.</span>add(stack_context<span style="color: #000000; font-weight: bold">.</span>wrap(callback))
    <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>_wake()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
就像前面说的, 为了通用, Tornado 在这些上下文的管理上可能做得比较巧妙, 在之后的版本当中, 这部分也可能变得比较复杂, 但是本质上的形式, 与最开始的那个理想化的例子是一致的.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">statck_context.StackContext</code> 对应于 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">HOLE</code> , 是一个上下文的管理容器(准确地说它只是一个操作接口, 容器是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.contexts</code> ). 而 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">statck_context.wrap</code> 则是一个类似于调度器的东西, 作用是给出正确的上下文环境, 理解它的关键是搞清楚"定义时状态"与"执行时状态"的关系与区别.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
接下来分块说一下 Tornado 中 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack_context.py</code> 的源码, 以 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">1.1.0</code> 版本为例.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">class</span> <span style="color: #445588; font-weight: bold">_State</span>(threading<span style="color: #000000; font-weight: bold">.</span>local):
    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">__init__</span>(<span style="color: #999999">self</span>):
        <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>contexts <span style="color: #000000; font-weight: bold">=</span> ()
_state <span style="color: #000000; font-weight: bold">=</span> _State()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里构造了一个线程安全的变量, 在 Tornado 运行时当中, 它就是全局量了, 所有上下文都会保存在里面. 在后面我们还会看到, 这部分的应用注意两点:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.contexts</code> 的类型是一个 <em style="color: #d75100; font-style: normal;">tuple</em> , <em style="color: #d75100; font-style: normal;">tuple</em> 这个类型是不可变的.
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.contexts</code> 这个名字会在不同的时候指向不同的 <em style="color: #d75100; font-style: normal;">tuple</em> , 搞清楚"引用"与"值"的关系.
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
接下来看 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">StackContext</code> :
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #3c5d5d; font-weight: bold">@contextlib.contextmanager</span>
<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">StackContext</span>(context_factory):
    old_contexts <span style="color: #000000; font-weight: bold">=</span> _state<span style="color: #000000; font-weight: bold">.</span>contexts
    <span style="color: #000000; font-weight: bold">try</span>:
        _state<span style="color: #000000; font-weight: bold">.</span>contexts <span style="color: #000000; font-weight: bold">=</span> old_contexts <span style="color: #000000; font-weight: bold">+</span> (context_factory,)
        <span style="color: #000000; font-weight: bold">with</span> context_factory():
            <span style="color: #000000; font-weight: bold">yield</span>
    <span style="color: #000000; font-weight: bold">finally</span>:
        _state<span style="color: #000000; font-weight: bold">.</span>contexts <span style="color: #000000; font-weight: bold">=</span> old_contexts
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
它是一个接收上下文对象的一个上下文对象, 可能后面版本的不使用装饰器写法更好看一些:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">class</span> <span style="color: #445588; font-weight: bold">StackContext</span>(<span style="color: #0086B3">object</span>):

    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">__init__</span>(<span style="color: #999999">self</span>, context_factory):
        <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>context_factory <span style="color: #000000; font-weight: bold">=</span> context_factory

    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">__enter__</span>(<span style="color: #999999">self</span>):
        <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>old_contexts <span style="color: #000000; font-weight: bold">=</span> _state<span style="color: #000000; font-weight: bold">.</span>contexts
        _state<span style="color: #000000; font-weight: bold">.</span>contexts <span style="color: #000000; font-weight: bold">=</span> old_contexts <span style="color: #000000; font-weight: bold">+</span> (context_factory,)

        <span style="color: #000000; font-weight: bold">try</span>:
            <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>context <span style="color: #000000; font-weight: bold">=</span> <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>context_factory()
            <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>context<span style="color: #000000; font-weight: bold">.</span>__enter__()
        <span style="color: #000000; font-weight: bold">except</span> <span style="color: #990000; font-weight: bold">Exception</span>:
            _state<span style="color: #000000; font-weight: bold">.</span>contexts <span style="color: #000000; font-weight: bold">=</span> <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>old_contexts
            <span style="color: #000000; font-weight: bold">raise</span>

    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">__exit__</span>(<span style="color: #999999">self</span>, <span style="color: #0086B3">type</span>, value, traceback):
        <span style="color: #000000; font-weight: bold">try</span>:
            <span style="color: #000000; font-weight: bold">return</span> <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>context<span style="color: #000000; font-weight: bold">.</span>__exit__(<span style="color: #0086B3">type</span>, value, traceback)
        <span style="color: #000000; font-weight: bold">finally</span>:
            _state<span style="color: #000000; font-weight: bold">.</span>contexts <span style="color: #000000; font-weight: bold">=</span> <span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>old_contexts
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
简单来说, 一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">StackContext</code> 实例的作用, 就是包装一个上下文对象, 代码在具体执行时, 还是使用原来的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">context_factory</code> , 但是传入的这个上下文对象会被保存到全局的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.contexts</code> 当中.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
单看这部分没有什么作用, 把上下文暂存起来的目的, 是为了在之后的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">wrap</code> 函数当中的, 可以给出当前的, 定义时的状态信息.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">wrap</span>(fn):
    <span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">wrapped</span>(callback, contexts, <span style="color: #000000; font-weight: bold">*</span>args, <span style="color: #000000; font-weight: bold">**</span>kwargs):
        pairs <span style="color: #000000; font-weight: bold">=</span> itertools<span style="color: #000000; font-weight: bold">.</span>izip(itertools<span style="color: #000000; font-weight: bold">.</span>chain(_state<span style="color: #000000; font-weight: bold">.</span>contexts,
                                               itertools<span style="color: #000000; font-weight: bold">.</span>repeat(<span style="color: #999999">None</span>)),
                               contexts)
        new_contexts <span style="color: #000000; font-weight: bold">=</span> []
        <span style="color: #000000; font-weight: bold">for</span> old, new <span style="color: #000000; font-weight: bold">in</span> itertools<span style="color: #000000; font-weight: bold">.</span>dropwhile(<span style="color: #000000; font-weight: bold">lambda</span> x: x[<span style="color: #009999">0</span>] <span style="color: #000000; font-weight: bold">is</span> x[<span style="color: #009999">1</span>], pairs):
            new_contexts<span style="color: #000000; font-weight: bold">.</span>append(StackContext(new))
        <span style="color: #000000; font-weight: bold">if</span> new_contexts:
            <span style="color: #000000; font-weight: bold">with</span> contextlib<span style="color: #000000; font-weight: bold">.</span>nested(<span style="color: #000000; font-weight: bold">*</span>new_contexts):
                callback(<span style="color: #000000; font-weight: bold">*</span>args, <span style="color: #000000; font-weight: bold">**</span>kwargs)
        <span style="color: #000000; font-weight: bold">else</span>:
            callback(<span style="color: #000000; font-weight: bold">*</span>args, <span style="color: #000000; font-weight: bold">**</span>kwargs)

    <span style="color: #000000; font-weight: bold">if</span> <span style="color: #0086B3">getattr</span>(fn, <span style="color: #dd1144">&#39;stack_context_wrapped&#39;</span>, <span style="color: #999999">False</span>):
        <span style="color: #000000; font-weight: bold">return</span> fn

    contexts <span style="color: #000000; font-weight: bold">=</span> _state<span style="color: #000000; font-weight: bold">.</span>contexts
    result <span style="color: #000000; font-weight: bold">=</span> functools<span style="color: #000000; font-weight: bold">.</span>partial(wrapped, fn, contexts)
    result<span style="color: #000000; font-weight: bold">.</span>stack_context_wrapped <span style="color: #000000; font-weight: bold">=</span> <span style="color: #999999">True</span>
    <span style="color: #000000; font-weight: bold">return</span> result
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">wrap</code> 是一个函数装饰, 在定义时, 把当前的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.contexts</code> 保存了下来, 而且参照之前的分析, 当前的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.contexts</code> 可能是被 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">StackContext</code> 替换过的(因为 <em style="color: #d75100; font-style: normal;">tuple</em> 不可变, 所以这里只能是"替换"). 之后, 在真正执行时, 又取一次 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.context</code> , 那这时, 定义时的上下文, 与执行时的上下文, 之间就可能存在差异, 这部分差异, 就是定义时有, 而执行时已经脱离的那些上下文, 脱离的这些上下文就是我们需要的 -- 它可以让一些函数的错误表现, 像另一些函数一样. 最后, 我们让回调函数在这些脱离了的上下文中执行(没脱离的上下文仍然有作用), 结果就是我们想要的, 相同的上下文继续作用于回调函数, 某个回调函数抛出了错误, 这些错误都可以按相同的方式处理.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
结合 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">StackContext</code> 与 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">wrap</code> 来看整个流程, 就是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">StackContext</code> 负责在某个地方挖个坑, 在其作用域范围内, 所有的回调函数如果 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">wrap</code> 了的话, 就都会在相同的坑里执行.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果你希望某些回调函数不受之前挖的坑的影响, 有一个临时的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">NullContext</code> 工具上下文, 它会动 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.context</code> , 把它清空. 这里有一点可以思考, 为什么不是去动 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">wrap</code> , 而在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.context</code> 上动手脚? 因为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">wrap</code> 是硬编码在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add_callback</code> 这类函数当中的, 但是它们都受 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.context</code> 的影响, 所以换个思维去动 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_state.context</code> 就可以达到目的.
</p>

<a class="anchor" name="toc5"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">5. 总结与比较</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
可以看到, Tornado 用一种可以说很取巧的方法, 解决了回调函数的异常表现问题.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
里面涉及了:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">with</code> 语法糖的使用( <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">with</code> 的作用可以使用函数替换, 只是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">with</code> 可以直接作用于一块语句, 而函数只能作用于一个函数).
</li>
<li style="margin: 10px auto;">全局量的使用.
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">itertools</code> 一系列工具的使用.
</li>
<li style="margin: 10px auto;">偏函数的应用, 这东西和"名字空间", "闭包"都有一些互补的关系.
</li>
<li style="margin: 10px auto;">还有一个与流程紧密相关的, 找出差异上下文的算法.
</li>
<li style="margin: 10px auto;">最后是这套机制是一个递归的使用结构.
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
比较我要说的是 nodejs 中的机制. 在官方的 API 中, <em style="color: #d75100; font-style: normal;">Domain</em> 是做这块上下文管理的模块.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
先回顾一下在简单的状态下我们碰到的问题:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">get</span>(<span style="color: #999999">self</span>):
    IL<span style="color: #000000; font-weight: bold">.</span>add_callback(<span style="color: #999999">self</span><span style="color: #000000; font-weight: bold">.</span>callback)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">self.callback</code> 的异常给我们造成了麻烦, 为了不让这个异常在全局蔓延开, 我们会很直接地想到在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">self.callback</code> 的执行上下文中把它给 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">try</code> 起来, 就是在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">IL</code> 中对所有的回调函数都 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">try</code> 一下, 这样只能说是单纯地拿到了异常, 但是在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">IL</code> 中并没有足够的信息, 让我们可以正确地处理这个异常(比如说返回 500 ). 所以, 这种简单直接的暴力大部分情况是没有用的.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
反观 nodejs , 这个问题似乎简单得多了, 它的上下文的概念, 就是一个对象, 应用事件模式, 通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">on</code> 定义事件回调, 通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">bind</code> 调度全局的事件回调函数用以处理异常.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在 nodejs 中, 使用:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">process.on(<span style="color: #dd1144">&#39;uncaughtException&#39;</span>, uncaughtHandler);
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
就可以直接拿到所有未捕获的异常. <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">domain.bind</code> 的执行会有一个注册行为, 后面执行 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">bind</code> 中的函数时就设置上当前的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">domain</code> , 这时如果有异常被 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">process</code> 的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">uncaughtException</code> 拿到, 就可以被当前的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">domain.on('error', callback)</code> 处理.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> d <span style="color: #000000; font-weight: bold">=</span> require(<span style="color: #dd1144">&#39;domain&#39;</span>).create();
<span style="color: #000000; font-weight: bold">var</span> d2 <span style="color: #000000; font-weight: bold">=</span> require(<span style="color: #dd1144">&#39;domain&#39;</span>).create();

d.on(<span style="color: #dd1144">&#39;error&#39;</span>, <span style="color: #000000; font-weight: bold">function</span>(error){
  console.error(<span style="color: #dd1144">&#39;error&#39;</span>, error);
});

d2.on(<span style="color: #dd1144">&#39;error&#39;</span>, <span style="color: #000000; font-weight: bold">function</span>(error){
  console.error(<span style="color: #dd1144">&#39;error2&#39;</span>, error);
});

d.bind(<span style="color: #000000; font-weight: bold">function</span>(){
  setTimeout(<span style="color: #000000; font-weight: bold">function</span>(){
    <span style="color: #000000; font-weight: bold">throw</span> <span style="color: #dd1144">&#39;I&#39;</span>;
  }, <span style="color: #009999">3000</span>);
})();

d2.bind(<span style="color: #000000; font-weight: bold">function</span>(){
  setTimeout(<span style="color: #000000; font-weight: bold">function</span>(){
    <span style="color: #000000; font-weight: bold">throw</span> <span style="color: #dd1144">&#39;II&#39;</span>;
  }, <span style="color: #009999">1000</span>);
})();
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
现在剩下的一个问题就是, 当你拿到一个异常时, 如果获取到正确的"当前 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">domain</code> ", 特别是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">setTimeout</code> 中的回调函数, 如何知道它对应的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">domain</code> 呢? 这个问题我看 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">domain.js</code> 的代码看了很久, 认为它是不可能的, 后来我到网上去找, 发现, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">timer.js</code> 中实现的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">setTimeout</code> 有处理 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">domain</code> 的东西, 我去......
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
至此, 比较 Tornado 和 nodejs 的 <em style="color: #d75100; font-style: normal;">Domain</em> , 其实它们本质上的使用行为是一致的, 一是都先要声明一个上下文的东西, 让这个东西在全局范围内被管理起来. 二是之后在具体的函数调用时, 声明使用一个上下文的调度行为.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
同时, 它们在实现上的行为与首手点却不相同. nodejs 使用全局的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">process</code> 拿到未捕获的异常, 在各个环节小心地控制 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">process.domain</code> , 通过事件模型实现对异常的统一处理. 从外部看来清晰简单, 但是事实上 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">setTimeout</code> 这种东西它里面隐藏了太多的细节.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
而 Tornado 并没有选择在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">ioloop</code> 层面对所有的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback</code> 做异常处理, 而是把这一个关键的集中点单独做到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack_context.py</code> 中, 并且以 Python 特殊的"上下文"对象这个更高层面的抽象来定义这个问题--异常处理只是上下文应用的一部分, 在直接结果上, 也只存在一个统一的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack</code> 来调度上下文就实现了嵌套等逻辑. 而 nodejs 中不光有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">active</code> 的概念, 也同样有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">stack</code> 的概念.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
Tornado 的实现我觉得很巧妙, 但是要弄明白确实要花些时间. nodejs 的 <em style="color: #d75100; font-style: normal;">Domain</em> 实现很直观, 只关注异常处理, 整个流程统一于事件模型, 但是需要低层的一些东西来支持.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
另外, 它们还有一点不同, Tornado 的上下文管理是一个必选项, 而 nodejs 的 <em style="color: #d75100; font-style: normal;">Domain</em> 功能则是可选的. 这点上的不同, 全造成如果 Tornado 按 nodejs 那种方式去解决问题, 会显得很别扭.
</p>

<style type="text/css">
body.z { background-color: #eff3fa; }
body.z > .content { background-color: white; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
body.z > .content > h1 { background-color: #0184b7; color: white; border-bottom: none; padding-left: 10px; border-radius: 5px; text-shadow: 0 2px 5px rgba(0, 0, 0, 0.9); }
body.z > .content > .toc a:hover { background-color: #ddd; }
body.z > .content > table th { background-color: rgba(223, 151, 27, 0.3);}
body.z > .content > .quote:before { content: '引'; font-size: 30px; color: #ddd; font-family: "'Microsoft YaHei','WenQuanYi Micro Hei',SimHei,tahoma,sans-serif"; }
body.z > .content ul > li, body.z > .content ol > li  { text-indent: -1em; }
body.z > .content  > .toc ul > li, body.z > .content  > .toc ol > li  { text-indent: 0; }
</style>
    

<script type="text/javascript" src="http://s.zys.me/js/jq/jquery.min.js"></script>
<script type="text/javascript">

$(function(){
    function bind_scroll(){
        $('body.z > .content > .toc ol').css({listStyle: 'none'})
        $('body.z > .content > .toc ul').css({listStyle: 'none'})
        $('body.z > .content > .toc a').css({display: 'block', paddingLeft: '10px'})

        var anchor_list = $.map($('.anchor'), function(n){
            return $(n).offset().top;
        });
        var item = $('body.z > .content > .toc a');
        var last = 0;
        var flag = 0;

        $(window).on('scroll', function(eventObj){
            _set_item();
        });

        function set_item(){
            var top = $(window).scrollTop();
            if(top < anchor_list[0]){
                item.eq(last).css({backgroundColor: '', color: '#0184b7'});
                last = 0;
                return;
            }

            for(var i = 0, l = anchor_list.length; i < l; i++){
                if(top < anchor_list[i]){break}
                flag = i;
            }
            item.eq(last).css({backgroundColor: '', color: '#0184b7'});
            item.eq(flag).css({backgroundColor: '#ddd', color: '#333'});
            last = flag;
        }

        var timer = null;
        function _set_item(){
            if(timer){
                clearTimeout(timer);
            }
            timer = setTimeout(set_item, 100);
        }
    }

    function create_toc(){
        if($('body.z > .content > .toc').length == 0){
            $('body.z > .content > .header').css('min-height', '200px');
            return;
        }
        if($('body.z > .content > .toc').height() < 50){return}

        //至少200空间
        var space = ($(window).width() - $('body.z > .content').outerWidth());
        if( space < 200 ){return}

        $('body.z > .content > .header').css('min-height', '200px');

        var toc_width = (space > 400 ? 400 : space);
        var content_left = (space - toc_width - 20) / 2;

        $('body.z > .content > .toc ol').css({
            paddingLeft: '20px'
        });
        $('body.z > .content > .toc ul').css({
            paddingLeft: '20px'
        });

        $('body.z > .content').css({
            marginLeft: content_left + 'px'
        });

        $('body.z > .content > .toc').css({
            fontSize: '12px',
            width: toc_width + 'px',
            backgroundColor: 'white',
            border: '1px solid #ccc',
            boxShadow: '0 2px 5px rgba(0, 0, 0, 0.3)',
            position: 'fixed',
            zIndex: 9999,
            padding: '10px',
            boxSizing: 'border-box',
            top: '50px',
            right: content_left + 'px',
            overflow: 'auto',
            maxHeight: $(window).height() - 100 + 'px'
        });

        bind_scroll();
    }

    function is_mobile(){
        if(window.devicePixelRatio > 1 || navigator.userAgent.indexOf('Android') >= 0){
            return true;
        }
        return false;
    }

    function mobile_meta(){
        var ua=navigator.userAgent;
        var meta = '';
        if(ua.indexOf('Android')!=-1){
            var isUC= /UC /.test(ua) || /UCBrowser/.test(ua) || /baidubrowser/.test(ua)|| /qq/i.test(ua);
            if(isUC){
                meta='<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,target-densitydpi=device-dpi,user-scalable=no" />';
            } else {
                meta='<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5,target-densitydpi=320,user-scalable=no" />';
            }
        }else{
            meta='<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5,target-densitydpi=device-dpi,user-scalable=no,minimal-ui" />';
        }
        $('head').append(meta);
    }

    function mobile_adjust(){
        $('body.z > .content').css({ width: '100%', padding: '15px' });
        $('#qr').hide();
        $('#disqus_thread').css({ width: '100%' });
        $('body.z').css({ letterSpacing: 0 });
        $('body.z p, body.z ul, body.z ol').css({ lineHeight: '1.5em' });
        $('body.z ul > li, body.z ol > li').css({ textIndent: '-2em' });
        $('body.z > .content > .toc ul > li, body.z > .content > .toc ol > li').css({ textIndent: 0, margin: 0 });
        $('body.z pre').css({ whiteSpace: 'pre-wrap', wordWrap: 'break-word' });
    }

    function normal_adjust(){
        $('body.z > .content > .toc ul > li, body.z > .content > .toc ol > li').css({ textIndent: 0, margin: 0 });
    }

    function code_view(){

        $('pre').click(function(eventObj){
            var $node = $($.clone(this));
            $node.attr('style', '');
            $node.css({
                fontSize: '24px',
                fontFamily: 'monospace',
                whiteSpace: 'pre-wrap',
                wordWrap: 'break-word',
                lineHeight: '1.5em',
                width: $(window).height(),
                height: $(window).width(),
                boxSizing: 'border-box',
                padding: '10px',
                paddingBottom: '30px',
                overflow: 'hidden'
            });
            var $wrapper = $('<div></div>').css({
                position: 'fixed',
                padding: 0,
                margin: 0,
                boxSizing: 'border-box',
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                width: $(window).height(),
                height: $(window).width(),
                overflow: 'hidden',
                top: ($(window).height() - $(window).width()) / 2,
                left: ($(window).width() - $(window).height()) / 2,
                transform: 'rotate(90deg)',
                zIndex: 999999
            });

            var $close = $('<div>&times;</div>').css({
                position: 'absolute',
                right: 0,
                top: 0,
                width: '100px',
                height: '100px',
                lineHeight: '80px',
                fontSize: '80px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)'
            });

            var $up = $('<div>△</div>').css({
                position: 'absolute',
                right: 0,
                bottom: '300px',
                width: '100px',
                height: '100px',
                lineHeight: '50px',
                fontSize: '50px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)',
                userSelect: 'none',
                '-webkit-user-select': 'none'
            });

            var $down = $('<div>▽</div>').css({
                position: 'absolute',
                right: 0,
                bottom: '100px',
                width: '100px',
                height: '100px',
                lineHeight: '150px',
                fontSize: '50px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)',
                userSelect: 'none',
                '-webkit-user-select': 'none'
            });

            $wrapper.append($node);
            $wrapper.append($close);
            $wrapper.append($up);
            $wrapper.append($down);

            $wrapper.on('touchstart', function(){
                return false;
            });

            $close.on('touchstart', function(){
                $close.css({ backgroundColor: '#0184b7' });
                return false;
            });
            $close.on('touchend', function(){

                $wrapper.off('touchend');
                $close.off('touchstart');
                $close.off('touchend');
                $up.off('touchstart');
                $up.off('touchend');
                $down.off('touchstart');
                $down.off('touchend');
                $wrapper.remove();

                return false;
            });

            var up_timer = null;
            $up.on('touchstart', function(eventObj){
                var start = $node.scrollTop();
                var dx = 0;
                $up.css({ backgroundColor: '#0184b7' });
                up_timer = setInterval(function(){
                    dx += 20;
                    $node.scrollTop(start - dx);
                }, 25);
                return false;
            });
            $up.on('touchend', function(eventObj){
                if(up_timer){clearInterval(up_timer)};
                $up.css({ backgroundColor: 'rgba(204, 204, 204, 0.5)' });
                return false;
            });

            var down_timer = null;
            $down.on('touchstart', function(eventObj){
                var start = $node.scrollTop();
                var dx = 0;
                $down.css({ backgroundColor: '#0184b7' });
                down_timer = setInterval(function(){
                    dx += 20;
                    $node.scrollTop(start + dx);
                }, 25);
                return false;
            });
            $down.on('touchend', function(eventObj){
                if(down_timer){clearInterval(down_timer)};
                $down.css({ backgroundColor: 'rgba(204, 204, 204, 0.5)' });
                return false;
            });

            $(this).before($wrapper);
        });
    
    }

    if(is_mobile()){
        mobile_meta();
        mobile_adjust();
        code_view();
    } else {
        create_toc();
        normal_adjust();
    }
});
</script>
    

    <div style="padding: 4px; line-height: 1.4em; font-size: 22px; margin-top: 100px; margin-bottom: 20px; clear: both; text-align: center; font-weight: bold; ">评论</div>
<div id="disqus_thread" style="width: 800px; margin: auto; "></div>
<script type="text/javascript">
  var disqus_shortname = 'zys';
  var disqus_identifier = 'context-in-async-env';
  var disqus_url = 'http://zouyesheng.com/context-in-async-env.html';
  var disqus_title = '异步调用中的上下文控制Tornado stack context ';

  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>评论功能需要javascript的支持</noscript>
    

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29492100-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
    

<div id="qr" style="position: absolute; right: 30px; top: 80px;"><img style="border: 1px solid gray;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKUAAAClAQAAAAAVUAB3AAABuElEQVR4nN2XMa7bMBBE31oC6FRU
kAPQF/mWr5QygH4sQL5H7pFKVE6RTjpAEKqKBMieFP7dd2kWyZRbzHIWM1zSxHusuwdF+NeqqAfc
jWLEUiGAsOQ7g0li8K81+A0nbfm0lTBXAZs+bfZSff5GPDXZ5/sSNlycND6Z93F14DKtVl0Pebuh
KMnFdB6BQk7acrpEZgZcaxfTl8NqVubUJkmKiQAQJEnZtKHed6JWN96zYKnI162EeT1I1a/Sfeda
uj8f18PPfNpufgtO2oKLanE3MmrbMQBLtC7Op1lieBbvQ+jmt0CdYAHg6Nt8CUA3mqCoDRfVBimd
c3oySnJK3FtSp4w7APU0QdIGQFDvu5wuAaZ9rC5BvW8njk/kfQ8pNWExdXL3mea8J1FM4Hq/3We6
ZPXkjiMN81cI64li9DE9ifchFCVh6kZqtWB5E3DfAdpQVBsUcyZgRzSzvSrCXlXDHt+NGV9BJtjX
U8ny4XfLMsxZd0BMBKf0ZkzwWV8KAMSqYanTJbieIt8k36pH77QfOI8L8+shZzevkR/pamtdXQ+Y
XE5tMjNUNUE9TOvpWbyPYP/xj+ovuKsNb0yIcg0AAAAASUVORK5CYII=
" title="本文二维码网址" /></div>
    

<div style="font-size: 10px; text-align: right; margin-top: 50px; letter-spacing: 0;">
&copy;2010-2015 zouyesheng.com All rights reserved. Powered by <a href="https://github.com/" target="_blank">GitHub</a> , <a href="http://txt2tags.org/" target="_blank">txt2tags</a> , <a href="http://www.mathjax.org/" target="_blank">MathJax</a>
</div>
    
<!-- xhtml code generated by txt2tags 2.6 (http://txt2tags.org) -->
</div></body></html>
