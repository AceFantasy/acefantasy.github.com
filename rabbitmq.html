<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
    <meta charset="UTF-8" />
    <title>RabbitMQ 使用参考 - YS.Zou</title>
    <meta name="generator" content="http://txt2tags.org" />
    <meta name="author" content="Yesheng Zou,YS.Zou,邹业盛"/>
</head>

<body class="z" style="color: #333; font-size: 16px; letter-spacing: 0.2em; font-family: 'Microsoft YaHei','WenQuanYi Micro Hei',SimHei,tahoma,sans-serif; -webkit-font-smoothing: antialiased; margin: 0;">
    <div class="content" style="width: 900px; margin: auto; padding: 30px; box-sizing: border-box; position: relative">
        <div class="header">
            <h1 style="text-align: center; font-size: 26px; margin: 0;">RabbitMQ 使用参考</h1>
            <div class="user" style="margin: 20px auto; text-align: center;">
                <span>邹业盛</span>
                <span>2016-01-10 16:55 更新</span>
            </div>
        </div>

<div class="toc">

  <ol style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
  <li style="margin: 10px auto;"><a href="#toc1" style="color: #0184b7; text-decoration: none">安装</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc2" style="color: #0184b7; text-decoration: none">基本概念</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc3" style="color: #0184b7; text-decoration: none">基本形式</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc4" style="color: #0184b7; text-decoration: none">持久化</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc5" style="color: #0184b7; text-decoration: none">调度策略</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc6" style="color: #0184b7; text-decoration: none">5.1. fanout</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc7" style="color: #0184b7; text-decoration: none">5.2. direct</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc8" style="color: #0184b7; text-decoration: none">5.3. topic</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc9" style="color: #0184b7; text-decoration: none">5.4. headers</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc10" style="color: #0184b7; text-decoration: none">分配策略</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc11" style="color: #0184b7; text-decoration: none">状态反馈</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc12" style="color: #0184b7; text-decoration: none">7.1. 信息发布的确认</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc13" style="color: #0184b7; text-decoration: none">7.2. 消息提取的确认</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc14" style="color: #0184b7; text-decoration: none">示例: 多消费者, 并行处理</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc15" style="color: #0184b7; text-decoration: none">示例: 一条消息多种处理, 临时队列</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc16" style="color: #0184b7; text-decoration: none">示例: 发布订阅, 多种形式的实现</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc17" style="color: #0184b7; text-decoration: none">示例: 远程调用, 信息流方向与角色转换</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc18" style="color: #0184b7; text-decoration: none">消息的BasicProperties</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc19" style="color: #0184b7; text-decoration: none">pika在Tornado中的使用</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc20" style="color: #0184b7; text-decoration: none">13.1. Producing</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc21" style="color: #0184b7; text-decoration: none">13.2. Consuming</a>
    </li>
    </ul>
  </li>
  </ol>

</div>

<a class="anchor" name="toc1"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">1. 安装</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
从网站 <a href="http://www.rabbitmq.com/install-generic-unix.html" style="color: #0184b7; text-decoration: none">http://www.rabbitmq.com/install-generic-unix.html</a> 下载到二进制源码, 进入 <em style="color: #d75100; font-style: normal;">sbin</em> 目录, 直接运行 server 即可.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
默认服务监听在 5672 端口上(带上 SSL 默认在 5671 上).
</p>

<a class="anchor" name="toc2"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">2. 基本概念</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">RabbitMQ</em> , 是一个使用 <em style="color: #d75100; font-style: normal;">erlang</em> 编写的 <em style="color: #d75100; font-style: normal;">AMQP</em> (高级消息队列协议) 的服务实现. 简单来说, 就是一个功能强大的消息队列服务.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
通常我们谈到队列服务, 会有三个概念, <em style="color: #d75100; font-style: normal;">发消息者</em> , <em style="color: #d75100; font-style: normal;">队列</em> , <em style="color: #d75100; font-style: normal;">收消息者</em> . ( <em style="color: #d75100; font-style: normal;">消息</em> 本来也应该算是一个独立的概念, 但是简单处理之下, 它可能并没有太多的内涵)
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
流程上是, <em style="color: #d75100; font-style: normal;">发消息者</em> 把消息放到 <em style="color: #d75100; font-style: normal;">队列</em> 中去, 然后 <em style="color: #d75100; font-style: normal;">收消息者</em> 从 <em style="color: #d75100; font-style: normal;">队列</em> 中取出消息.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在 <em style="color: #d75100; font-style: normal;">发消息者</em> 和 <em style="color: #d75100; font-style: normal;">队列</em> 之间, 加入了 <em style="color: #d75100; font-style: normal;">交换器</em> (Exchange) . 这样 <em style="color: #d75100; font-style: normal;">发消息者</em> 和 <em style="color: #d75100; font-style: normal;">队列</em> 就没有直接联系, 转而变成 <em style="color: #d75100; font-style: normal;">发消息者</em> 把消息给 <em style="color: #d75100; font-style: normal;">交换器</em> , <em style="color: #d75100; font-style: normal;">交换器</em> 根据调度策略再把消息再给 <em style="color: #d75100; font-style: normal;">队列</em> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
当然, 多一层抽象会增加复杂度, 但是同时, 功能上也更灵活. 事实上, 很多时候面对具体场景时, 在这种"四段式"的结构下, 你可选择的方案不止一种的. 不过也不必过于担心, 在一些自我规定的"原则"之下, "正确"的方案也不会那么纠结.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
总结一下 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">4 + 1</code> 个概念, 或者说, 五种角色:
</p>

<dl style="">
<dt style=""><em style="color: #d75100; font-style: normal;">Producing</em> , 生产者, 产生消息的角色.</dt><dd style="">
</dd>
<dt style=""><em style="color: #d75100; font-style: normal;">Exchange</em> , 交换器, 在得到生产者的消息后, 把消息扔到队列的角色.</dt><dd style="">
</dd>
<dt style=""><em style="color: #d75100; font-style: normal;">Queue</em> , 队列, 消息暂时呆的地方.</dt><dd style="">
</dd>
<dt style=""><em style="color: #d75100; font-style: normal;">Consuming</em> , 消费者, 把消息从队列中取出的角色.</dt><dd style="">
</dd>
<dt style=""><em style="color: #d75100; font-style: normal;">消息 Message</em> , RabbitMQ 中的消息有自己的一系列属性, 某些属性对信息流有直接影响.</dt><dd style="">
</dd>
</dl>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在使用过程中, 我们通常还会关注如下的机制:
</p>

<dl style="">
<dt style=""><em style="color: #d75100; font-style: normal;">持久化</em> , 服务重启时, 是否能恢复队列中的数据.</dt><dd style="">
</dd>
<dt style=""><em style="color: #d75100; font-style: normal;">调度策略</em> , 交换器如何把消息给到哪些队列, 是每个队列给一条, 或者把一条消息给多个队列.</dt><dd style="">
</dd>
<dt style=""><em style="color: #d75100; font-style: normal;">分配策略</em> , 队列面对消费者时, 如何把消息吐出去, 来一个消费者就把消息全给它, 还是只给一条.</dt><dd style="">
</dd>
<dt style=""><em style="color: #d75100; font-style: normal;">状态反馈</em> , 当消息从某一个队列中被提出后, 这个消息的生命周期就此结束, 还是说需要一个具体的信号以明确标识消息已被正确处理.</dt><dd style="">
</dd>
</dl>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面这些内容, 初看之下好像情况有些复杂了, 不过在具体使用过程中, 这些东西都是很自然地需要考虑的. 当一套服务跑起来之后, 这些细枝末节自然消失在无形之中.
</p>

<a class="anchor" name="toc3"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">3. 基本形式</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
当服务启在 5672 端口之后, 我们就可以开始使用 <em style="color: #d75100; font-style: normal;">RabbitMQ</em> 了.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
根据前面的内容, 我们需要站在两个角度(消息的提供方, 和消息的使用方), 去分别考虑五种角色的情况. 当然, 在使用时其实只是两个角度, 每边四种角色的情况. 因为消息的提供方不关心使用方, 反之, 消息的使用方也不关心消息的提供方. 这种关系上的无依赖本身是"队列服务"的一个最大使用意义所在, 用于业务间的分离(不管是分了好, 还是必须分).
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
我们先看如何产生消息, 即把消息放到队列当中, 等待下一步的处理.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
(之后的代码, 使用 Python , 相应的 AMQP 协议实现的模块是 <em style="color: #d75100; font-style: normal;">pika</em> )
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面代码的细节先不用管它, 但是直观看到做的事有:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">获取连接.
</li>
<li style="margin: 10px auto;">从连接上获取一个 <em style="color: #d75100; font-style: normal;">channel</em> , 类似于数据库访问在连接上获取一个 <em style="color: #d75100; font-style: normal;">cursor</em> .
</li>
<li style="margin: 10px auto;">声明一个 <em style="color: #d75100; font-style: normal;">exchange</em> . (只会创建一次)
</li>
<li style="margin: 10px auto;">声明一个 <em style="color: #d75100; font-style: normal;">queue</em> . (只会创建一次)
</li>
<li style="margin: 10px auto;">把 <em style="color: #d75100; font-style: normal;">queue</em> 绑定到 <em style="color: #d75100; font-style: normal;">exchange</em> 上.
</li>
<li style="margin: 10px auto;">向指定的 <em style="color: #d75100; font-style: normal;">exchange</em> 发送一条消息.
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
消息发出之后, 可以使用 <em style="color: #d75100; font-style: normal;">rabbitmqctl</em> 这个工具查看服务的一些当前状态, 比如队列情况:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #008080">$ </span>./rabbitmqctl list_queues
Listing queues ...
hello    3
...done.
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
然后是另一边, 从队列取出消息:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(ch, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body

channel<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
channel<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
前面部分和之前的一样, 获取连接, 拿到 <em style="color: #d75100; font-style: normal;">channel</em> . 这里声明 <em style="color: #d75100; font-style: normal;">queue</em> 是在做重复的事(之前 <em style="color: #d75100; font-style: normal;">Producing</em> 的代码已经做过声明了). 但是 <em style="color: #d75100; font-style: normal;">Producing</em> 和 <em style="color: #d75100; font-style: normal;">Consuming</em> 的代码你并不知道哪一个会先执行, 所以为了确保需要的 <em style="color: #d75100; font-style: normal;">queue</em> 是存在的, 使用时总先声明一下是好的方式.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
接下来就是定义了一个异步回调, 标明在获取到消息之后要执行的处理函数.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
最后, 开始接收服务器的消息.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
和前面一样, 看一下代码做的事:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">获取连接.
</li>
<li style="margin: 10px auto;">从连接上拿到 <em style="color: #d75100; font-style: normal;">channel</em> .
</li>
<li style="margin: 10px auto;">声明需要的 <em style="color: #d75100; font-style: normal;">queue</em> .
</li>
<li style="margin: 10px auto;">定义一个从指定 <em style="color: #d75100; font-style: normal;">queue</em> 获取消息的回调处理.
</li>
<li style="margin: 10px auto;">开始接收消息.
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
两边的代码都完成了, 可以先把取出消息的代码跑起来, 然后再重复运行产生消息的代码, 就能看到效果.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里我们可以先反思一下我们的思维. 从流程上来说, 之前我们是先考虑如何产生消息, 然后是如何获取消息. 我们按这个顺序来编写了两段代码. 但是我们在使用时, 顺序反过来是一种更直观的方式. 即先是有服务跑起来, 守着等消息. 然后才是不定时有消息产生出来. 这一前一后在思维上是有一些微妙的不同的. 如果从 <em style="color: #d75100; font-style: normal;">C/S</em> 结构上来看, <em style="color: #d75100; font-style: normal;">Consuming</em> 的角色更像是 <em style="color: #d75100; font-style: normal;">Server</em> , 而 <em style="color: #d75100; font-style: normal;">Producing</em> 的角色更像是 <em style="color: #d75100; font-style: normal;">Client</em> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
为什么在这里讲这个呢, 是因为稍后会依次介绍整个流程中的细节, 比如 <em style="color: #d75100; font-style: normal;">exchange</em> 的调度策略, 多个 <em style="color: #d75100; font-style: normal;">Producing</em> , 多个 <em style="color: #d75100; font-style: normal;">Consuming</em> , 多个 <em style="color: #d75100; font-style: normal;">Queue</em> 的情况下, 我们如何去实现期望的行为. 当系统中的元素与角色有些多的时候, 我们需要一个比较明确的思维方式来保持自己的清醒.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
基本的流程就是前面的两段代码. 接下来会依次介绍提到过的, 我们关心的几个机制.
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">持久化</em>
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">调度策略</em>
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">分配策略</em>
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">状态反馈</em>
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
然后, 会有几个实例分析, 用以演示一些典型的使用模式.
</p>

<a class="anchor" name="toc4"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">4. 持久化</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
考虑这样的场景, 当消息被暂存到队列后, 在没有被提取的情况下, RabbitMQ 服务停掉了怎么办.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的代码, 我们创建了一条内容为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Hello World!</code> 的消息, 通过命令行工具:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #008080">$ </span> ./rabbitmqctl list_queues
Listing queues ...
hello    1
...done.

<span style="color: #008080">$ </span>./rabbitmqctl list_exchanges
Listing exchanges ...
    direct
amq.direct    direct
amq.fanout    fanout
amq.headers    headers
amq.match    headers
amq.rabbitmq.log    topic
amq.rabbitmq.trace    topic
amq.topic    topic
first    fanout
...done.
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
可以查到, 在名为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">hello</code> 的队列中, 有 1 条消息. 有一个类型为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">fanout</code> , 名为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">first</code> 的交换器.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
此时通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Ctrl-C</code> 或 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">./rabbitmqctl stop</code> 把 RabbitMQ 服务停掉, 再重启. 交换器, 队列, 消息都是不会恢复的.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
所以, 默认情况下, <em style="color: #d75100; font-style: normal;">消息</em>, <em style="color: #d75100; font-style: normal;">队列</em>, <em style="color: #d75100; font-style: normal;">交换器</em> 都不具有持久化的性质. 如果我们需要持久化功能, 那么在声明的时候就需要配置好.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
交换器和队列的持久化性质, 在声明时通过一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">durable</code> 参数即可实现:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>, durable<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>, durable<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样, 在服务重启之后, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">first</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">hello</code> 都会恢复. 但是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">hello</code> 中的消息不会, 还需要额外配置. 这是 <em style="color: #d75100; font-style: normal;">消息</em> 的属性的相关内容:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                      routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>,
                      body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>,
                      properties<span style="color: #000000; font-weight: bold">=</span>pika<span style="color: #000000; font-weight: bold">.</span>BasicProperties(
                         delivery_mode <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">2</span>,
                      ))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">properties</code> , 把此条消息, 仅仅是此条消息配置成需要持久化的. 这样, 在服务重启之后, 队列中的这种消息就可以恢复.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里注意一下, 消息的持久化并不是一个很强的约束, 涉及数据落地的时机, 及系统层面的 <em style="color: #d75100; font-style: normal;">fsync</em> 等问题, 不要认为消息完全不会丢. 如果要尽可能高地提高消息的持久化的有效性, 还需要配置其它的一些机制, 比如后面会谈到的 <em style="color: #d75100; font-style: normal;">状态反馈</em> 中的 <em style="color: #d75100; font-style: normal;">confirm mode</em>.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">交换器</em> , <em style="color: #d75100; font-style: normal;">队列</em>, <em style="color: #d75100; font-style: normal;">消息</em> 这三者的持久化问题都介绍过了. 前两者是一经声明, 则其性质无法再被更改, 即你不能先声明一个非持久化的队列, 再声明一个持久化的同名队列, 企图修改它, 这是不行的. 你重复声明时, 相关参数需要一致. 当然, 你可以删除它们再重新声明:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">channel<span style="color: #000000; font-weight: bold">.</span>queue_delete(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>exchange_delete(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc5"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">5. 调度策略</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
我们考虑交换器 <em style="color: #d75100; font-style: normal;">Exchange</em> 和队列 <em style="color: #d75100; font-style: normal;">Queue</em> 的关系. <em style="color: #d75100; font-style: normal;">Exchange</em> 在得到消息后会依据规则把消息投到一个或多个队列当中.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在调度策略方面, 有两个需要了解的地方, 一是交换器的类型(前面我们用的是 <em style="color: #d75100; font-style: normal;">fanout</em>), 二是交换器和队列的绑定关系. 在绑定了的前提下, 我们再谈不同类型的交换器的规则. 绑定动作本身也会影响交换器的行为.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
交换器的类型, 内置的有四种, 分别是:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">fanout</em>
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">direct</em>
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">topic</em>
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">headers</em>
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
下面一一介绍.
</p>

<a class="anchor" name="toc6"></a>
<h2 style="font-size: 18px; margin: 30px auto;">5.1. fanout</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
故名思义, <em style="color: #d75100; font-style: normal;">fanout</em> 类型的交换器, 其行为是把消息转发给所有绑定的队列上, 就是一个"广播"行为.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;B&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;C&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;B&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                      routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>,
                      body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
运行 N 次, 通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rabbitmqctl</code> 可以看到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">B</code> 中就有 N 条消息, 而 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">C</code> 中没有消息. 因为只有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">B</code> 是绑定到了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">first</code> 上的.
</p>

<a class="anchor" name="toc7"></a>
<h2 style="font-size: 18px; margin: 30px auto;">5.2. direct</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">direct</em> 类型的行为是"先匹配, 再投送". 即在绑定时设定一个 <em style="color: #d75100; font-style: normal;">routing_key</em> , 消息的 <em style="color: #d75100; font-style: normal;">routing_key</em> 匹配时, 才会被交换器投送到绑定的队列中去.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;direct&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;B&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;a&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;B&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;b&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                      routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;a&#39;</span>,
                      body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">B</code> 虽然都绑定在了类型为 <em style="color: #d75100; font-style: normal;">direct</em> 的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">first</code> 上, 但是绑定时的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">routing_key</code> 不同.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
当一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">routing_key</code> 为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">a</code> 的消息出来时, 只会被 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">first</code> 投送到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 里.
</p>

<a class="anchor" name="toc8"></a>
<h2 style="font-size: 18px; margin: 30px auto;">5.3. topic</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">topic</em> 和 <em style="color: #d75100; font-style: normal;">direct</em> 类似, 只是匹配上支持了"模式", 在"点分"的 <em style="color: #d75100; font-style: normal;">routing_key</em> 形式中, 可以使用两个通配符:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">*</code> 表示一个词.
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">#</code> 表示零个或多个词.
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;topic&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;B&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;a.*.*&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;B&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;a.#&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                      routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;a&#39;</span>,
                      body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                      routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;a.b.c&#39;</span>,
                      body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在发出的两条消息当中, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">a</code> 只会被 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">a.#</code> 匹配到. 而 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">a.b.c</code> 会被两个都匹配到.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
所以, 最终的结果会是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 中有一条消息, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">B</code> 中有两条消息.
</p>

<a class="anchor" name="toc9"></a>
<h2 style="font-size: 18px; margin: 30px auto;">5.4. headers</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">headers</em> 也是根据规则匹配, 相较于 <em style="color: #d75100; font-style: normal;">direct</em> 和 <em style="color: #d75100; font-style: normal;">topic</em> 固定地使用 <em style="color: #d75100; font-style: normal;">routing_key</em> , <em style="color: #d75100; font-style: normal;">headers</em> 则是一个自定义匹配规则的类型.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">headers</code> 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;headers&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;B&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, arguments<span style="color: #000000; font-weight: bold">=</span>{<span style="color: #dd1144">&#39;a&#39;</span>: <span style="color: #dd1144">&#39;1&#39;</span>})
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;B&#39;</span>, arguments<span style="color: #000000; font-weight: bold">=</span>{<span style="color: #dd1144">&#39;b&#39;</span>: <span style="color: #dd1144">&#39;2&#39;</span>, <span style="color: #dd1144">&#39;c&#39;</span>: <span style="color: #009999">3</span>, <span style="color: #dd1144">&#39;x-match&#39;</span>: <span style="color: #dd1144">&#39;all&#39;</span>})

channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                      routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>,
                      properties<span style="color: #000000; font-weight: bold">=</span>pika<span style="color: #000000; font-weight: bold">.</span>BasicProperties(
                          headers <span style="color: #000000; font-weight: bold">=</span> {<span style="color: #dd1144">&#39;a&#39;</span>: <span style="color: #dd1144">&#39;2&#39;</span>},
                      ),
                      body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                      routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>,
                      properties<span style="color: #000000; font-weight: bold">=</span>pika<span style="color: #000000; font-weight: bold">.</span>BasicProperties(
                          headers <span style="color: #000000; font-weight: bold">=</span> {<span style="color: #dd1144">&#39;a&#39;</span>: <span style="color: #dd1144">&#39;1&#39;</span>, <span style="color: #dd1144">&#39;b&#39;</span>: <span style="color: #dd1144">&#39;2&#39;</span>},
                      ),
                      body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
绑定时, 通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">arguments</code> 参数设定匹配规则, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">x-match</code> 是一个特殊的规则, 表示需要全部匹配上, 还是只匹配一条:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">all</code> , 全部匹配.
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">any</code> , 只匹配一个.
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
消息的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">headers</code> 属性会用于规则的匹配.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的代码中, 第一条消息不会匹配任何规则. 第二条消息, 匹配到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> , 但是不会匹配到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">B</code> (虽然有一条 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">b:2</code> ).
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
最终的结果是, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 中有一条消息, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">B</code> 中没有消息.
</p>

<a class="anchor" name="toc10"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">6. 分配策略</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
调度策略是影响 <em style="color: #d75100; font-style: normal;">Exchange</em> 是不是要把消息给 <em style="color: #d75100; font-style: normal;">Queue</em> , 而分配策略影响队列如何把消息给 <em style="color: #d75100; font-style: normal;">Consuming</em> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
考虑这样的场景: 队列中有多条消息, 每一个消费者取出消息后, 都要花 10 秒来处理它, 处理完一条消息之后才可能再取出一条继续处理. 刚开始只有一个消费者, 过了 2 秒后来了第二个消费者, 此时, 这两个消费者获取消息的行为是一个什么状态?
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
我们的需求可能是, 当一个消费者来时, 只给它一条消息, 等它再"请求"时, 再给. 或者也可能是, 当有消费者时, 就把目前有的消息全给它(因为不知道是否还有其它的消费者, 所以既然来了一个就让它尽量多处理一些消息).
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
先产生一些等待处理的消息:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)

<span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> <span style="color: #0086B3">range</span>(<span style="color: #009999">10</span>):
    channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                          routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>,
                          body<span style="color: #000000; font-weight: bold">=</span><span style="color: #0086B3">str</span>(i))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
然后是消费者的实现:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(ch, method, properties, body):
    <span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">time</span>
    time<span style="color: #000000; font-weight: bold">.</span>sleep(<span style="color: #009999">10</span>)
    <span style="color: #000000; font-weight: bold">print</span> body

channel<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
channel<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的代码, 是假设处理一条消息需要 10 秒的时间. 但是事实上, 你只要一执行代码, 马上再使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rabbitmqctl</code> 查看队列状态时, 会发现队列已经空了. 因为在关闭 <em style="color: #d75100; font-style: normal;">ack</em> 的情况下, <em style="color: #d75100; font-style: normal;">Queue</em> 的行为是, 一旦有消费者请求, 那么当前队列中的消息它都会一次性吐很多出去.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">ack</em> 机制在后面 <em style="color: #d75100; font-style: normal;">状态反馈</em> 会介绍到, 简单来说是一种确认消息被正确处理的机制.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果我们想一次只吐一条消息, 当其它消费者连上来时, 还可以并行处理, 简单地把 <em style="color: #d75100; font-style: normal;">ack</em> 打开就可以了(默认就是打开的).
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
再考虑一下细节. 当有多个消费者连上时, 它是从队列一次取一条消息, 还是一次取多条消息(这样至少可以改善性能). 这可以通过配置 <em style="color: #d75100; font-style: normal;">channel</em> 的 <em style="color: #d75100; font-style: normal;">qos</em> 相关参数实现:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>basic_qos(prefetch_count<span style="color: #000000; font-weight: bold">=</span><span style="color: #009999">2</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(ch, method, properties, body):
    <span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">time</span>
    time<span style="color: #000000; font-weight: bold">.</span>sleep(<span style="color: #009999">10</span>)
    <span style="color: #000000; font-weight: bold">print</span> body
    ch<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

channel<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>)
channel<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
通过配置 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">prefetch_count</code> 参数, 来设置一次从队列中取多少条消息. 要看到效果, 至少需要启 2 个消费者.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
之前是 10 个数字按顺序入了队列, <em style="color: #d75100; font-style: normal;">channel</em> 的配置是一次取 2 个, 那么启 2 个消费者的话, 过 10 秒, 在两个消费者的输出中分别能看到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">0</code> , <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">2</code> . 这时把两个消费者都 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Ctrl-C</code> , 通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rabbitmqctl</code> 能看到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 队列中还有 8 条消息.
</p>

<a class="anchor" name="toc11"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">7. 状态反馈</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">状态反馈</em> 的功能目的是为了确认行为的结果. 比如, 当你向 <em style="color: #d75100; font-style: normal;">Exchange</em> 提交一个消息时, 这个消息是否提交成功, 是否送达到了队列中. 当你从队列中提取消息之后, <em style="color: #d75100; font-style: normal;">RabbitMQ</em> 的 Server 如何处理, 因为在提取消息之后, <em style="color: #d75100; font-style: normal;">Consuming</em> 可能判断消息有问题, 可能在处理的过程中出现了异常.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在一些关键的节点上, 要保证消息的正确处理, 安全处理, 是需要很多细节上的控制的. <em style="color: #d75100; font-style: normal;">AMQP</em> 协议本身也为此作了相关设计, 甚至是事务机制. 事实上在 <em style="color: #d75100; font-style: normal;">AMQP</em> 中要确保消息的业务可靠性只能使用事务, 不过在 <em style="color: #d75100; font-style: normal;">RabbitMQ</em> 中有一些相应的简便的扩展机制来达到同样目的.
</p>

<a class="anchor" name="toc12"></a>
<h2 style="font-size: 18px; margin: 30px auto;">7.1. 信息发布的确认</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
回看一下之前的一段代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello World!&#39;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这段代码要做的事, 是把一条消息发给名为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">first</code> 的交换器. 这个过程中可能出现意外:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">exchange</code> 的名字写错了.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">exchange</em> 得到消息后, 发现没有对应的 <em style="color: #d75100; font-style: normal;">queue</em> 可以投送.
</li>
<li style="margin: 10px auto;">投送到 <em style="color: #d75100; font-style: normal;">queue</em> 后当前没有消费者来提取它.
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的三种情况, 第一种, 会直接引发一个调用错误. 第三种, 通常不是问题, 反正消息会在 <em style="color: #d75100; font-style: normal;">queue</em> 中暂存. 但是第二种情况很多时候是需要避免的, 否则消息就丢失了, 更严重的是 <em style="color: #d75100; font-style: normal;">Producing</em> 对此浑然不知.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在这个地方, 我们就需要确认消息发出之后, 是否成功地被投送到 <em style="color: #d75100; font-style: normal;">queue</em> 中去了(或者知道它不能被投送到任何 <em style="color: #d75100; font-style: normal;">queue</em> 中去).
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
要确认这些状态信息, 首先需要把 <em style="color: #d75100; font-style: normal;">channel</em> 设置到 <em style="color: #d75100; font-style: normal;">confirm mode</em> , 也称之为 <em style="color: #d75100; font-style: normal;">Publisher Acknowledgements</em> 机制 (和消息的 <em style="color: #d75100; font-style: normal;">ack</em> 机制区分开). 它的目的就是为了确认 <em style="color: #d75100; font-style: normal;">Producing</em> 发出的信息的状态.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
打开 <em style="color: #d75100; font-style: normal;">confirm mode</em> 的方法是:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">channel<span style="color: #000000; font-weight: bold">.</span>confirm_delivery()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
之后的 <em style="color: #d75100; font-style: normal;">publish</em> 行为就可以收到服务器的反馈. 比如在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">basic_publish</code> 函数中, 通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">mandatory=True</code> 参数来确认发出的消息是否有 <em style="color: #d75100; font-style: normal;">queue</em> 接收, 并且所有 <em style="color: #d75100; font-style: normal;">queue</em> 都成功接收.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)

<span style="color: #999988">#channel.queue_bind(exchange=&#39;first&#39;, queue=&#39;A&#39;)</span>

channel<span style="color: #000000; font-weight: bold">.</span>confirm_delivery()

r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>,
                          routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>,
                          body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;Hello&#39;</span>,
                          mandatory<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>,
                         )
<span style="color: #000000; font-weight: bold">print</span> r
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的代码中, 因为名为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">first</code> 的 <em style="color: #d75100; font-style: normal;">Exchange</em> 没有绑定任何的 <em style="color: #d75100; font-style: normal;">queue</em> , 在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">mandatory</code> 参数的作用下, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">basic_publish</code> 会返回 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">False</code> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
对于持久化性质, <em style="color: #d75100; font-style: normal;">confirm mode</em> 的确认结果是表示, 一条 <em style="color: #d75100; font-style: normal;">persisting</em> 的消息, 投送给一个 <em style="color: #d75100; font-style: normal;">durable</em> 的队列成功, 并且数据已经成功写到磁盘. 当然, 因为系统缓存的问题, 为确保数据成功落地, 得到确认信息有时可能需要长达几百毫秒的时间, 应用对此应该有所准备, 而不至于在性能上受此影响.
</p>

<a class="anchor" name="toc13"></a>
<h2 style="font-size: 18px; margin: 30px auto;">7.2. 消息提取的确认</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在未关闭消息的 <em style="color: #d75100; font-style: normal;">ack</em> 机制的情况下, 当消息被 <em style="color: #d75100; font-style: normal;">Consuming</em> 从队列中提取后, 在未明确获取确认信息之前, 队列中的消息是不会被删除的. 这样, 流程上就变成, 当消息被提取之后, 队列中的这条消息处于"等待确认"的状态. 如果 <em style="color: #d75100; font-style: normal;">Consuming</em> 反馈"成功"给队列, 则消息可以安全地被删除了. 如果反馈"拒绝"给队列, 则消息可能还需要再次被其它 <em style="color: #d75100; font-style: normal;">Consuming</em> 提取.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
看下面的例子, 我们先创建顺序的 10 个数字为内容的 10 条消息:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)

<span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> <span style="color: #0086B3">range</span>(<span style="color: #009999">10</span>):
    channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #0086B3">str</span>(i))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
提取消息的逻辑:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>basic_get(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>) <span style="color: #999988">#0</span>
<span style="color: #000000; font-weight: bold">print</span> r[<span style="color: #000000; font-weight: bold">-</span><span style="color: #009999">1</span>], r[<span style="color: #009999">0</span>]<span style="color: #000000; font-weight: bold">.</span>delivery_tag
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的代码会提取第一条消息, 但是并没有向 <em style="color: #d75100; font-style: normal;">Queue</em> 反馈此消息是否被正确处理, 所以这条消息在队列中仍然存在, 直到 <em style="color: #d75100; font-style: normal;">Connection</em> 被释放后, 被提取过但是未被确认的消息的状态被重置, 它就可以被重新提取.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
要确认消息, 或者拒绝消息, 使用对应的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">basic_ack</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">baskc_reject</code> 方法:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>basic_get(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>) <span style="color: #999988">#0</span>
<span style="color: #000000; font-weight: bold">print</span> r[<span style="color: #000000; font-weight: bold">-</span><span style="color: #009999">1</span>], r[<span style="color: #009999">0</span>]<span style="color: #000000; font-weight: bold">.</span>delivery_tag
<span style="color: #999988">#channel.basic_ack(delivery_tag=r[0].delivery_tag)</span>
channel<span style="color: #000000; font-weight: bold">.</span>basic_reject(delivery_tag<span style="color: #000000; font-weight: bold">=</span>r[<span style="color: #009999">0</span>]<span style="color: #000000; font-weight: bold">.</span>delivery_tag)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">AMQP</em> 协议中, 只提供了 <em style="color: #d75100; font-style: normal;">reject</em> 方法, 它只能处理一条消息. 因为 <em style="color: #d75100; font-style: normal;">Consuming</em> 是可以一次性提取多条消息的, 所以 <em style="color: #d75100; font-style: normal;">RabbitMQ</em> 为此做了扩展, 提供了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">basic_nack</code> 方法, 它和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">basic_reject</code> 的唯一区别就是支持一次性拒绝多条消息.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>basic_get(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>) <span style="color: #999988">#0</span>
r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>basic_get(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>) <span style="color: #999988">#1</span>
r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>basic_get(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>) <span style="color: #999988">#2</span>
channel<span style="color: #000000; font-weight: bold">.</span>basic_nack(delivery_tag<span style="color: #000000; font-weight: bold">=</span>r[<span style="color: #009999">0</span>]<span style="color: #000000; font-weight: bold">.</span>delivery_tag, multiple<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">delivery_tag</code> 是在 <em style="color: #d75100; font-style: normal;">channel</em> 中的一个消息计数, 每次消息提取行为都对应一个数字. <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">nack</code> 的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">multiple</code> 机制会自动把不大于指定 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">delivery_tag</code> 的消息提取都 <em style="color: #d75100; font-style: normal;">reject</em> 掉.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">reject</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">nack</code> 中还有一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">requeue</code> 参数, 表示被拒绝的消息是否可以被重新分配. 默认是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">True</code> . 如果消息被 <em style="color: #d75100; font-style: normal;">reject</em> 之后, 不希望再被其它的 <em style="color: #d75100; font-style: normal;">Consuming</em> 得到, 可以把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">requeue</code> 参数设置成 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">False</code> :
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>basic_get(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>, no_ack<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>) <span style="color: #999988">#0</span>
channel<span style="color: #000000; font-weight: bold">.</span>basic_nack(delivery_tag<span style="color: #000000; font-weight: bold">=</span>r[<span style="color: #009999">0</span>]<span style="color: #000000; font-weight: bold">.</span>delivery_tag, multiple<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>, requeue<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">False</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">basic_consume</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">basic_get</code> 都是从指定 <em style="color: #d75100; font-style: normal;">queue</em> 中提取消息, 前者是一个更高层的方法, 还支持 <em style="color: #d75100; font-style: normal;">qos</em> 等.
</p>

<a class="anchor" name="toc14"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">8. 示例: 多消费者, 并行处理</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这可能是最常遇到的一种场景了. 消息产生之后堆到队列里, 有多个消费者的 <em style="color: #d75100; font-style: normal;">worker</em> 来共同处理这些消息, 以并行的方式提高处理效率.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这种场景在 <em style="color: #d75100; font-style: normal;">Exchange</em> 的类似选择上, 不管是 <em style="color: #d75100; font-style: normal;">fanout</em> 或者是 <em style="color: #d75100; font-style: normal;">direct</em> 都可以实现. 稍有不同在于, <em style="color: #d75100; font-style: normal;">fanout</em> 类型的话, 你在一个 <em style="color: #d75100; font-style: normal;">exchange</em> 上就不要乱绑定队列. <em style="color: #d75100; font-style: normal;">direct</em> 类型的话, 则是需要每条消息自己处理好 <em style="color: #d75100; font-style: normal;">routing_key</em> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里以 <em style="color: #d75100; font-style: normal;">fanout</em> 类型先创建一些消息到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 这个队列中:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)

channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)

<span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> <span style="color: #0086B3">range</span>(<span style="color: #009999">10</span>):
    channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #0086B3">str</span>(i))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
消费者的实现没什么特别的:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>basic_qos(prefetch_count<span style="color: #000000; font-weight: bold">=</span><span style="color: #009999">1</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(ch, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body
    <span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">time</span>
    time<span style="color: #000000; font-weight: bold">.</span>sleep(<span style="color: #009999">4</span>)
    ch<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

channel<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
多个消费者直接跑就行了. <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">A</code> 中的消息会被多个 <em style="color: #d75100; font-style: normal;">Consuming</em> 提取处理.
</p>

<a class="anchor" name="toc15"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">9. 示例: 一条消息多种处理, 临时队列</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">fanout</em> 典型的广播模式就是我们这里考虑的场景, 其它的还有像"发布/订阅"的模式也是这种. 就是一条消息, 最终会有多个消费者得到它(前面说的多消费者并行处理的场景, 是一条消息, 只会给到一个消费者).
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
实现上, 自然可以是当一个消费者被创建之后, 同时也创建一个自己的 <em style="color: #d75100; font-style: normal;">queue</em> , 然后绑定到指定的 <em style="color: #d75100; font-style: normal;">exchange</em> 上.  每个 <em style="color: #d75100; font-style: normal;">Consuming</em> 有自己的 <em style="color: #d75100; font-style: normal;">queue</em> , 那么于其自己做一套命名方法, 不如就忽略 <em style="color: #d75100; font-style: normal;">queue</em> 的名字, 让系统处理, 这就是 <em style="color: #d75100; font-style: normal;">临时队列</em> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在声明队列时, 不指定名字:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>queue_declare()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
系统会创建一个队列, 并且随机给一个类似于 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">amq.gen-a_rJcuQ1mJigV9xp5G_uZQ</code> 这样的名字. 从返回的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">r</code> 中可以得到这个信息. 接下来, 就可以把这个队列绑定到 <em style="color: #d75100; font-style: normal;">exchange</em> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
但是还有一个问题, <em style="color: #d75100; font-style: normal;">Consuming</em> 自己创建了一个 <em style="color: #d75100; font-style: normal;">queue</em> , 那么在 <em style="color: #d75100; font-style: normal;">Consuming</em> 断掉连接之后, 这个 <em style="color: #d75100; font-style: normal;">queue</em> 也是应该被销毁的. 自己在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">on_close</code> 之类的事件回调中处理不是不过以, 不过 <em style="color: #d75100; font-style: normal;">RabbitMQ</em> 有提供现成的机制, 声明 <em style="color: #d75100; font-style: normal;">queue</em> 时使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">exclusive=True</code> 即可:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(exclusive<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样当连接断掉后, 声明的 <em style="color: #d75100; font-style: normal;">queue</em> 会被自动删除(相应的 <em style="color: #d75100; font-style: normal;">bind</em> 关系也会取消).
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
一个即插即用的 <em style="color: #d75100; font-style: normal;">Consuming</em> 就是:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(exclusive<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span>r<span style="color: #000000; font-weight: bold">.</span>method<span style="color: #000000; font-weight: bold">.</span>queue)
channel<span style="color: #000000; font-weight: bold">.</span>basic_qos(prefetch_count<span style="color: #000000; font-weight: bold">=</span><span style="color: #009999">1</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(ch, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body
    <span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">time</span>
    time<span style="color: #000000; font-weight: bold">.</span>sleep(<span style="color: #009999">4</span>)
    ch<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

channel<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span>r<span style="color: #000000; font-weight: bold">.</span>method<span style="color: #000000; font-weight: bold">.</span>queue)
channel<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
特别之处只是动态创建 <em style="color: #d75100; font-style: normal;">queue</em> .
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这种情况下的 <em style="color: #d75100; font-style: normal;">Producing</em> , 就只关注 <em style="color: #d75100; font-style: normal;">Exchange</em> , 不关心 <em style="color: #d75100; font-style: normal;">queue</em> 了:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)

<span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> <span style="color: #0086B3">range</span>(<span style="color: #009999">10</span>):
    channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #0086B3">str</span>(i))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc16"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">10. 示例: 发布订阅, 多种形式的实现</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
"发布/订阅"的模式, 在前面已经提过. 简单地使用临时队列就可以实现.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
不过在这里, 我们多思考一点. "发布"的形式倒是单一, 就是把消息提交到 <em style="color: #d75100; font-style: normal;">exchange</em> . 但是 "订阅" 的行为, 就可以有多种解释了.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
最简单的创建一个临时队列, <em style="color: #d75100; font-style: normal;">bind</em> 到了 <em style="color: #d75100; font-style: normal;">exchange</em> 上, 就算是"订阅了这个 <em style="color: #d75100; font-style: normal;">exchange</em> ".
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
其它, 还可以针对 <em style="color: #d75100; font-style: normal;">direct</em> 或 <em style="color: #d75100; font-style: normal;">topic</em> 类型的 <em style="color: #d75100; font-style: normal;">exchange</em> , 创建临时队列之后, <em style="color: #d75100; font-style: normal;">bind</em> 到 <em style="color: #d75100; font-style: normal;">exchange</em> 上时指定 <em style="color: #d75100; font-style: normal;">routing_key</em> , 这可以说是"订阅了这个 <em style="color: #d75100; font-style: normal;">exchange</em> 中的某些 <em style="color: #d75100; font-style: normal;">消息</em> ". <em style="color: #d75100; font-style: normal;">headers</em> 类型的 <em style="color: #d75100; font-style: normal;">exchange</em> 同理.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
换个角度来看这个问题, 是选择使用 <em style="color: #d75100; font-style: normal;">exchange</em> 来分割消息, 还是使用 <em style="color: #d75100; font-style: normal;">routing_key</em> 来分割消息. 前者在 <em style="color: #d75100; font-style: normal;">Producing</em> 阶段会比较麻烦, 因为你需要往多个 <em style="color: #d75100; font-style: normal;">exchange</em> 提交消息. 而后者在 <em style="color: #d75100; font-style: normal;">Producing</em> 和 <em style="color: #d75100; font-style: normal;">Consuming</em> 阶段都要多做一些事, <em style="color: #d75100; font-style: normal;">Producing</em> 阶段需要正确设定消息的 <em style="color: #d75100; font-style: normal;">routing_key</em> , 在 <em style="color: #d75100; font-style: normal;">Consuming</em> 阶段 <em style="color: #d75100; font-style: normal;">bind</em> 时也需要正确设置 <em style="color: #d75100; font-style: normal;">routing_key</em> . 更进一步说, 我们在提交消息时, 是愿意选择 <em style="color: #d75100; font-style: normal;">exchange</em> , 还是更愿意考虑给一个合适的 <em style="color: #d75100; font-style: normal;">routing_key</em> 呢?
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
当然, <em style="color: #d75100; font-style: normal;">exchange</em> 和 <em style="color: #d75100; font-style: normal;">routing_key</em> 肯定不是矛盾的. 它们是两个层面的抽象, 彼此应该独立. 在具体业务中使用时, 也应该对应到合适的业务抽象层中去. 就消息而言, 如果是一个有多项目的大系统共用一个 <em style="color: #d75100; font-style: normal;">RabbitMQ</em> 服务, 那在 <em style="color: #d75100; font-style: normal;">exchange</em> 这层可能就是"项目"的分割. 而如果这种环境下你把 <em style="color: #d75100; font-style: normal;">exchange</em> 搞成"业务"的分割, 情况就复杂了, 我认为这是错误的设计. "面向数据而不是面向业务"的原则, 在这里同样适用.
</p>

<a class="anchor" name="toc17"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">11. 示例: 远程调用, 信息流方向与角色转换</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
队列系统有一个很本质的东西, 就是信息流的方向是单一的. 信息总是被放进 <em style="color: #d75100; font-style: normal;">queue</em> 后, 再被取出.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
考虑远程调用的模型, "调用"本身是一个"请求/响应"的过程, 这是两个方向的信息流. 对应到队列中, 两个方向, 则至少需要两个队列. 想明白了这点, 我们要做的事就清楚了:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">                  +------------------+   
      +----------&gt;|     queue A      |------------+
      |           +------------------+            |
      |                                           v
  +-------+                                   +-------+
  |       |                                   |       |
  +-------+                                   +-------+
      ^                                           |
      |           +------------------+            |
      +-----------|     queue B      |&lt;-----------+
                  +------------------+
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上图是我们要实现的信息流, 左侧是调用方, 要做的事是把参数写到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">queue A</code> , 然后从 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">queue B</code> 中取出结果. 右侧是计算方, 要做的事是从 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">queue A</code> 中取出参数, 运算后把结果写到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">queue B</code> 中.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
计算方的代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

conn <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
ch <span style="color: #000000; font-weight: bold">=</span> conn<span style="color: #000000; font-weight: bold">.</span>channel()
ch<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(channel, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body
    s <span style="color: #000000; font-weight: bold">=</span> <span style="color: #0086B3">sum</span>(<span style="color: #0086B3">int</span>(x) <span style="color: #000000; font-weight: bold">for</span> x <span style="color: #000000; font-weight: bold">in</span> body<span style="color: #000000; font-weight: bold">.</span>split(<span style="color: #dd1144">&#39;,&#39;</span>))
    channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #0086B3">str</span>(s))
    channel<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

ch<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
逻辑是从 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_p</code> 中取出数据, 计算后把结果写到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_r</code> 中.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
调用方代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

conn <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
ch <span style="color: #000000; font-weight: bold">=</span> conn<span style="color: #000000; font-weight: bold">.</span>channel()
ch<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(channel, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body
    channel<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

ch<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>,  body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;1,2,3,4&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
逻辑是把参数写到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_p</code> 中, 然后等着从 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_r</code> 中读出结果.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
两段代码, 实现了最简单的功能. 但是这样有一个很明显的问题, 调用和输出之间, 是没有任何联系的, 即函数调用的输入和输出之间无法对应起来. 当有多个调用方时, 就乱套了. 所以我们需要改进一下, 让输入和输出能一一对应上.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
输入部分不用改, 还是使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_p</code> 保存参数. 输出部分, 我们把一个确定的 <em style="color: #d75100; font-style: normal;">queue</em> 换成每次生成的临时队列, 并且把其对应的 <em style="color: #d75100; font-style: normal;">exchange</em> 改成 <em style="color: #d75100; font-style: normal;">headers</em> 类型, 目的是通过 <em style="color: #d75100; font-style: normal;">headers</em> 参数实现, 从 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_p</code> 取出一组参数之后, 往 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_r</code> 写回的东西只路由到特定的一个临时队列去.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
计算方代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

conn <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
ch <span style="color: #000000; font-weight: bold">=</span> conn<span style="color: #000000; font-weight: bold">.</span>channel()
ch<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;headers&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(channel, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body
    s <span style="color: #000000; font-weight: bold">=</span> <span style="color: #0086B3">sum</span>(<span style="color: #0086B3">int</span>(x) <span style="color: #000000; font-weight: bold">for</span> x <span style="color: #000000; font-weight: bold">in</span> body<span style="color: #000000; font-weight: bold">.</span>split(<span style="color: #dd1144">&#39;,&#39;</span>))
    q <span style="color: #000000; font-weight: bold">=</span> properties<span style="color: #000000; font-weight: bold">.</span>headers[<span style="color: #dd1144">&#39;q&#39;</span>]
    channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #0086B3">str</span>(s),
                              properties<span style="color: #000000; font-weight: bold">=</span>pika<span style="color: #000000; font-weight: bold">.</span>BasicProperties(
                                  headers <span style="color: #000000; font-weight: bold">=</span> {<span style="color: #dd1144">&#39;q&#39;</span>: q},
                              )
                         )
    channel<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

ch<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
计算之后, 往 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_r</code> 中写回数据时, 数据带上特殊的头, 而特殊的头的值则是原始消息中自带的, 指明了这组参数对应的临时队列.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
调用方的代码改成:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

conn <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
ch <span style="color: #000000; font-weight: bold">=</span> conn<span style="color: #000000; font-weight: bold">.</span>channel()
ch<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;headers&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(channel, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body
    channel<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

rq <span style="color: #000000; font-weight: bold">=</span> ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(exclusive<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
qname <span style="color: #000000; font-weight: bold">=</span> rq<span style="color: #000000; font-weight: bold">.</span>method<span style="color: #000000; font-weight: bold">.</span>queue
ch<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span>qname, arguments<span style="color: #000000; font-weight: bold">=</span>{<span style="color: #dd1144">&#39;q&#39;</span>: qname})
ch<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span>qname)
ch<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>,  body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;1,2,3&#39;</span>,
                     properties<span style="color: #000000; font-weight: bold">=</span>pika<span style="color: #000000; font-weight: bold">.</span>BasicProperties(
                          headers <span style="color: #000000; font-weight: bold">=</span> {<span style="color: #dd1144">&#39;q&#39;</span>: qname},
                     )
                 )
ch<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
调用前生成一个用于保存结果的临时队列, 把这个队列绑定到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_r</code> 这个交换器上, 并且规定了一个路由规则.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
然后把参数写到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rpc_p</code> 时, 同时也在数据中写入了结果队列的路由规则.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这是一个很常用的"先挖坑, 再填坑"的方式.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
同理, 换成 <em style="color: #d75100; font-style: normal;">direct</em> 类型的 <em style="color: #d75100; font-style: normal;">exchange</em> , 以 <em style="color: #d75100; font-style: normal;">routing_key</em> 保存路由规则也能实现类似的效果.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
道理就是上面讲的, 不过做同样的事, <em style="color: #d75100; font-style: normal;">RabbitMQ</em> , 或者说 <em style="color: #d75100; font-style: normal;">AMQP</em> 中有一些事先定义的参数可以直接拿来用. 比如消息中的 <em style="color: #d75100; font-style: normal;">reply_to</em> 参数来标明此消息处理后的结果往哪个队列中送, <em style="color: #d75100; font-style: normal;">correlation_id</em> 来标明"请求"与"响应"的对应关系.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
计算方实现:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

conn <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
ch <span style="color: #000000; font-weight: bold">=</span> conn<span style="color: #000000; font-weight: bold">.</span>channel()
ch<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;direct&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(channel, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body
    s <span style="color: #000000; font-weight: bold">=</span> <span style="color: #0086B3">sum</span>(<span style="color: #0086B3">int</span>(x) <span style="color: #000000; font-weight: bold">for</span> x <span style="color: #000000; font-weight: bold">in</span> body<span style="color: #000000; font-weight: bold">.</span>split(<span style="color: #dd1144">&#39;,&#39;</span>))
    channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span>properties<span style="color: #000000; font-weight: bold">.</span>reply_to, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #0086B3">str</span>(s),
                          properties<span style="color: #000000; font-weight: bold">=</span>pika<span style="color: #000000; font-weight: bold">.</span>BasicProperties(correlation_id<span style="color: #000000; font-weight: bold">=</span>properties<span style="color: #000000; font-weight: bold">.</span>correlation_id))
    channel<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

ch<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
调用方实现:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">uuid</span>

conn <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
ch <span style="color: #000000; font-weight: bold">=</span> conn<span style="color: #000000; font-weight: bold">.</span>channel()
ch<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;direct&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)
ch<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(channel, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body, properties<span style="color: #000000; font-weight: bold">.</span>correlation_id
    channel<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

rq <span style="color: #000000; font-weight: bold">=</span> ch<span style="color: #000000; font-weight: bold">.</span>queue_declare(exclusive<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
qname <span style="color: #000000; font-weight: bold">=</span> rq<span style="color: #000000; font-weight: bold">.</span>method<span style="color: #000000; font-weight: bold">.</span>queue
ch<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_r&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span>qname, routing_key<span style="color: #000000; font-weight: bold">=</span>qname)
ch<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span>qname)
ch<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;rpc_p&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span>qname,  body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;1,2,3&#39;</span>,
                 properties<span style="color: #000000; font-weight: bold">=</span>pika<span style="color: #000000; font-weight: bold">.</span>BasicProperties(
                     reply_to <span style="color: #000000; font-weight: bold">=</span> qname,
                     correlation_id <span style="color: #000000; font-weight: bold">=</span> uuid<span style="color: #000000; font-weight: bold">.</span>uuid4()<span style="color: #000000; font-weight: bold">.</span>hex
                 ))
ch<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc18"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">12. 消息的BasicProperties</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在 <em style="color: #d75100; font-style: normal;">AMQP</em> 协议中, 为消息预定了 14 个属性, 有些在前面我们已经用到过了, 有些则本来就很少用到:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">content_type</em> 标明消息的类型.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">content_encoding</em> 标明消息的编码.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">headers</em> 可扩展的信息对.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">delivery_mode</em> 为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">2</code> 时表示该消息需要被持久化支持.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">priority</em> 该消息的权重.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">correlation_id</em> 用于"请求"与"响应"之间的匹配.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">reply_to</em> "响应"的目标队列.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">expiration</em> 有效期.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">message_id</em> 消息的ID.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">timestamp</em> 一个时间戳.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">type</em> 消息的类型.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">user_id</em> 用户的ID.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">app_id</em> 应用的ID.
</li>
<li style="margin: 10px auto;"><em style="color: #d75100; font-style: normal;">cluster_id</em> 服务集群ID.
</li>
</ul>

<a class="anchor" name="toc19"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">13. pika在Tornado中的使用</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
前面的介绍中, 我们都使用的是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">BlockingConnection</code> , 是一个同步阻塞的交互模型. <em style="color: #d75100; font-style: normal;">pika</em> 的代码本身在组织时, 其实是以异步的方式来架构的, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">BlockingConnection</code> 不过是一个特殊的封装而已.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">pika</em> 提供了多种异步调度机制的适配实现, 对应 Tornado 的是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">TornadoConnection</code> . 同时, 在 <em style="color: #d75100; font-style: normal;">channel</em> 的 API 上, 本身就有 <em style="color: #d75100; font-style: normal;">callback</em> 的实现, 所以, 把之前的代码改成异步的形式, 多是在获取 <em style="color: #d75100; font-style: normal;">Connection</em> 和 <em style="color: #d75100; font-style: normal;">channel</em> 这两步上的异步形式调整.
</p>

<a class="anchor" name="toc20"></a>
<h2 style="font-size: 18px; margin: 30px auto;">13.1. Producing</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
先看同步的代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()

channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
channel<span style="color: #000000; font-weight: bold">.</span>confirm_delivery()

r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;hello&#39;</span>, mandatory<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
<span style="color: #000000; font-weight: bold">print</span> r
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
它做的事有:
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">获取连接.
</li>
<li style="margin: 10px auto;">从连接上获取 <em style="color: #d75100; font-style: normal;">channel</em> .
</li>
<li style="margin: 10px auto;">声明 <em style="color: #d75100; font-style: normal;">exchange</em> .
</li>
<li style="margin: 10px auto;">声明 <em style="color: #d75100; font-style: normal;">queue</em> .
</li>
<li style="margin: 10px auto;">绑定 <em style="color: #d75100; font-style: normal;">exchange</em> 和 <em style="color: #d75100; font-style: normal;">queue</em> .
</li>
<li style="margin: 10px auto;">打开 <em style="color: #d75100; font-style: normal;">confirm mode</em> .
</li>
<li style="margin: 10px auto;">发出消息.
</li>
<li style="margin: 10px auto;">确认结果.
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
除了前面两步: "获取连接" 和 "从连接上获取 <em style="color: #d75100; font-style: normal;">channel</em> " , 其它的操作都是在 <em style="color: #d75100; font-style: normal;">channel</em> 上完成的. 对应到 Tornado 上来做, 就是:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.gen</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.ioloop</span>

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">on_confirm</span>(method):
    <span style="color: #000000; font-weight: bold">print</span> method

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">on_publish</span>((ch, method, prop, body)):
    <span style="color: #000000; font-weight: bold">print</span> method<span style="color: #000000; font-weight: bold">.</span>reply_code

<span style="color: #3c5d5d; font-weight: bold">@tornado.gen.engine</span>
<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">on_channel</span>(channel):
    method <span style="color: #000000; font-weight: bold">=</span> <span style="color: #000000; font-weight: bold">yield</span> tornado<span style="color: #000000; font-weight: bold">.</span>gen<span style="color: #000000; font-weight: bold">.</span>Task(channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare, exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
    method <span style="color: #000000; font-weight: bold">=</span> <span style="color: #000000; font-weight: bold">yield</span> tornado<span style="color: #000000; font-weight: bold">.</span>gen<span style="color: #000000; font-weight: bold">.</span>Task(channel<span style="color: #000000; font-weight: bold">.</span>queue_declare, queue<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;A&#39;</span>)
    <span style="color: #999988">#method = yield tornado.gen.Task(channel.queue_bind, exchange=&#39;first&#39;, queue=&#39;A&#39;)</span>
    channel<span style="color: #000000; font-weight: bold">.</span>confirm_delivery(callback<span style="color: #000000; font-weight: bold">=</span>on_confirm, nowait<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
    channel<span style="color: #000000; font-weight: bold">.</span>add_on_return_callback(on_publish)
    channel<span style="color: #000000; font-weight: bold">.</span>basic_publish(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, routing_key<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;&#39;</span>, body<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;good&#39;</span>, mandatory<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
    <span style="color: #999988">#channel.basic_publish(exchange=&#39;first&#39;, routing_key=&#39;&#39;, body=&#39;good&#39;)</span>
    <span style="color: #999988">#channel.close()</span>

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">on_connect</span>(conn):
    conn<span style="color: #000000; font-weight: bold">.</span>channel(on_open_callback<span style="color: #000000; font-weight: bold">=</span>on_channel)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">publish</span>():
    pika<span style="color: #000000; font-weight: bold">.</span>TornadoConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>),
                           on_open_callback<span style="color: #000000; font-weight: bold">=</span>on_connect)

<span style="color: #000000; font-weight: bold">if</span> __name__ <span style="color: #000000; font-weight: bold">==</span> <span style="color: #dd1144">&#39;__main__&#39;</span>:
    publish()
    tornado<span style="color: #000000; font-weight: bold">.</span>ioloop<span style="color: #000000; font-weight: bold">.</span>IOLoop()<span style="color: #000000; font-weight: bold">.</span>current()<span style="color: #000000; font-weight: bold">.</span>start()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
代码好像会复杂一些, 不过继续封装一下用起来也可以很方便.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
前面提到过, 好消息是 <em style="color: #d75100; font-style: normal;">channel</em> 的所有 API 都带有 <em style="color: #d75100; font-style: normal;">callback</em> 实现, 说的是 <em style="color: #d75100; font-style: normal;">channel</em> 有所有 API 几乎都有一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback</code> 参数. 坏消息是, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback</code> 参数全是第一个参数. 所以, 如果要直接使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">tornado.gen.engine</code> 的话, 后面的参数需要全带上参数名以 <em style="color: #d75100; font-style: normal;">keyword</em> 形式传递.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
从上面异步结构的代码中, 更容易把 <em style="color: #d75100; font-style: normal;">RabbitMQ</em> 自己扩展实现的 <em style="color: #d75100; font-style: normal;">confirm mode</em> 说清楚了.
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">channel<span style="color: #000000; font-weight: bold">.</span>confirm_delivery(callback<span style="color: #000000; font-weight: bold">=</span>on_confirm, nowait<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
是打开 <em style="color: #d75100; font-style: normal;">confirm mode</em> 功能, 当向服务器 publish 一条消息, 服务器确认消息之后, 就会回调这里指定的函数. 回调的内容要么是 <em style="color: #d75100; font-style: normal;">ACK</em> , 要么是 <em style="color: #d75100; font-style: normal;">NACK</em> . 按官方文档的说法, 出现 <em style="color: #d75100; font-style: normal;">NACK</em> 的情况只可能是服务内部出现了错误. 而正确的回调函数被执行时, 意即服务器确认了消息内容, 消息已经被所有对应的队列接收, 如果是需要持久化支持的内容, 则相关数据已经写到磁盘.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
后面的:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">channel<span style="color: #000000; font-weight: bold">.</span>add_on_return_callback(on_publish)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
是对应 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">mandatory=True</code> 的回调的. 即当 publish 出去的消息无法被投递到任何队列时, 服务会回调这里的函数.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的 <em style="color: #d75100; font-style: normal;">confirm</em> 和 <em style="color: #d75100; font-style: normal;">on_return</em> 是两套东西. 示例代码执行时, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">mandatory=True</code> 生效的情况下, 你会看到如下输入:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">312
&lt;METHOD([&#39;channel_number=1&#39;, &#39;frame_type=1&#39;, &quot;method=&lt;Basic.Ack([&#39;delivery_tag=1&#39;, &#39;multiple=False&#39;])&gt;&quot;])&gt;
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
先执行的是 <em style="color: #d75100; font-style: normal;">on_return</em> 的回调, 再是 <em style="color: #d75100; font-style: normal;">confirm</em> 的回调.
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
还有一点, 从:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">channel<span style="color: #000000; font-weight: bold">.</span>add_on_return_callback(on_publish)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里也可以看出, <em style="color: #d75100; font-style: normal;">pika</em> 的 API 组织上, <em style="color: #d75100; font-style: normal;">channel</em> 中有很多的回调函数是单独定义的(可能有 <em style="color: #d75100; font-style: normal;">AMQP</em> 协议有关).
</p>

<dl style="">
<dt style=""><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add_callback(callback, replies, one_shot=True)</code></dt><dd style="">
    在当前 <em style="color: #d75100; font-style: normal;">channel</em> 上注册指定类型的事件回调.
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;"></p>
</dd>
<dt style=""><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add_on_cancel_callback(callback)</code></dt><dd style="">
    使用 <em style="color: #d75100; font-style: normal;">basic_cancel</em> 回调的函数.
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;"></p>
</dd>
<dt style=""><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add_on_close_callback(callback)</code></dt><dd style="">
    <em style="color: #d75100; font-style: normal;">channel</em> 关闭时回调的函数.
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;"></p>
</dd>
<dt style=""><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add_on_return_callback(callback)</code></dt><dd style="">
    <em style="color: #d75100; font-style: normal;">basic_publish</em> 中的消息被拒绝时的回调函数.
</dd>
</dl>

<a class="anchor" name="toc21"></a>
<h2 style="font-size: 18px; margin: 30px auto;">13.2. Consuming</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">Consuming</em> 部分在异步环境上比 <em style="color: #d75100; font-style: normal;">Producing</em> 部分还简单一点. 最大的不同, 可能在于异步环境下需要自己控制对消息的提取(提取之后再次监听, 而不像同步环境下一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">while</code>).
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
先看同步的代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>

connection <span style="color: #000000; font-weight: bold">=</span> pika<span style="color: #000000; font-weight: bold">.</span>BlockingConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>))
channel <span style="color: #000000; font-weight: bold">=</span> connection<span style="color: #000000; font-weight: bold">.</span>channel()
channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
r <span style="color: #000000; font-weight: bold">=</span> channel<span style="color: #000000; font-weight: bold">.</span>queue_declare(exclusive<span style="color: #000000; font-weight: bold">=</span><span style="color: #999999">True</span>)
channel<span style="color: #000000; font-weight: bold">.</span>queue_bind(exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span>r<span style="color: #000000; font-weight: bold">.</span>method<span style="color: #000000; font-weight: bold">.</span>queue)
channel<span style="color: #000000; font-weight: bold">.</span>basic_qos(prefetch_count<span style="color: #000000; font-weight: bold">=</span><span style="color: #009999">1</span>)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">callback</span>(ch, method, properties, body):
    <span style="color: #000000; font-weight: bold">print</span> body
    <span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">time</span>
    time<span style="color: #000000; font-weight: bold">.</span>sleep(<span style="color: #009999">4</span>)
    ch<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)

channel<span style="color: #000000; font-weight: bold">.</span>basic_consume(callback, queue<span style="color: #000000; font-weight: bold">=</span>r<span style="color: #000000; font-weight: bold">.</span>method<span style="color: #000000; font-weight: bold">.</span>queue)
channel<span style="color: #000000; font-weight: bold">.</span>start_consuming()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
异步代码:
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #999988"># -*- coding: utf-8 -*-</span>

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">pika</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.gen</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">tornado.ioloop</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #555555">functools</span>

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">on_msg</span>(qname, ch, method, prop, body):
    <span style="color: #000000; font-weight: bold">print</span> qname, body
    ch<span style="color: #000000; font-weight: bold">.</span>basic_ack(delivery_tag <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>delivery_tag)
    ch<span style="color: #000000; font-weight: bold">.</span>basic_consume(functools<span style="color: #000000; font-weight: bold">.</span>partial(on_msg, qname), queue<span style="color: #000000; font-weight: bold">=</span>qname)

<span style="color: #3c5d5d; font-weight: bold">@tornado.gen.engine</span>
<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">on_channel</span>(channel):
    method <span style="color: #000000; font-weight: bold">=</span> <span style="color: #000000; font-weight: bold">yield</span> tornado<span style="color: #000000; font-weight: bold">.</span>gen<span style="color: #000000; font-weight: bold">.</span>Task(channel<span style="color: #000000; font-weight: bold">.</span>exchange_declare, exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, <span style="color: #0086B3">type</span><span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;fanout&#39;</span>)
    method <span style="color: #000000; font-weight: bold">=</span> <span style="color: #000000; font-weight: bold">yield</span> tornado<span style="color: #000000; font-weight: bold">.</span>gen<span style="color: #000000; font-weight: bold">.</span>Task(channel<span style="color: #000000; font-weight: bold">.</span>queue_declare)
    qname <span style="color: #000000; font-weight: bold">=</span> method<span style="color: #000000; font-weight: bold">.</span>method<span style="color: #000000; font-weight: bold">.</span>queue
    method <span style="color: #000000; font-weight: bold">=</span> <span style="color: #000000; font-weight: bold">yield</span> tornado<span style="color: #000000; font-weight: bold">.</span>gen<span style="color: #000000; font-weight: bold">.</span>Task(channel<span style="color: #000000; font-weight: bold">.</span>queue_bind, exchange<span style="color: #000000; font-weight: bold">=</span><span style="color: #dd1144">&#39;first&#39;</span>, queue<span style="color: #000000; font-weight: bold">=</span>qname)
    method <span style="color: #000000; font-weight: bold">=</span> <span style="color: #000000; font-weight: bold">yield</span> tornado<span style="color: #000000; font-weight: bold">.</span>gen<span style="color: #000000; font-weight: bold">.</span>Task(channel<span style="color: #000000; font-weight: bold">.</span>basic_qos, prefetch_count<span style="color: #000000; font-weight: bold">=</span><span style="color: #009999">1</span>)
    channel<span style="color: #000000; font-weight: bold">.</span>basic_consume(functools<span style="color: #000000; font-weight: bold">.</span>partial(on_msg, qname), queue<span style="color: #000000; font-weight: bold">=</span>qname)


<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">on_connect</span>(conn):
    conn<span style="color: #000000; font-weight: bold">.</span>channel(on_open_callback<span style="color: #000000; font-weight: bold">=</span>on_channel)

<span style="color: #000000; font-weight: bold">def</span> <span style="color: #990000; font-weight: bold">consume</span>():
    pika<span style="color: #000000; font-weight: bold">.</span>TornadoConnection(pika<span style="color: #000000; font-weight: bold">.</span>ConnectionParameters(<span style="color: #dd1144">&#39;localhost&#39;</span>),
                           on_open_callback<span style="color: #000000; font-weight: bold">=</span>on_connect)

<span style="color: #000000; font-weight: bold">if</span> __name__ <span style="color: #000000; font-weight: bold">==</span> <span style="color: #dd1144">&#39;__main__&#39;</span>:
    consume()
    tornado<span style="color: #000000; font-weight: bold">.</span>ioloop<span style="color: #000000; font-weight: bold">.</span>IOLoop()<span style="color: #000000; font-weight: bold">.</span>current()<span style="color: #000000; font-weight: bold">.</span>start()
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>


<style type="text/css">
body.z { background-color: #eff3fa; }
body.z > .content { background-color: white; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
body.z > .content > h1 { background-color: #0184b7; color: white; border-bottom: none; padding-left: 10px; border-radius: 5px; text-shadow: 0 2px 5px rgba(0, 0, 0, 0.9); }
body.z > .content > .toc a:hover { background-color: #ddd; }
body.z > .content > table th { background-color: rgba(223, 151, 27, 0.3);}
body.z > .content > .quote:before { content: '引'; font-size: 30px; color: #ddd; font-family: "'Microsoft YaHei','WenQuanYi Micro Hei',SimHei,tahoma,sans-serif"; }
body.z > .content ul > li, body.z > .content ol > li  { text-indent: -1em; }
body.z > .content  > .toc ul > li, body.z > .content  > .toc ol > li  { text-indent: 0; }
</style>
    

<script type="text/javascript" src="https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript">

$(function(){
    function bind_scroll(){
        $('body.z > .content > .toc ol').css({listStyle: 'none'})
        $('body.z > .content > .toc ul').css({listStyle: 'none'})
        $('body.z > .content > .toc a').css({display: 'block', paddingLeft: '10px'})

        var anchor_list = $.map($('.anchor'), function(n){
            return $(n).offset().top;
        });
        var item = $('body.z > .content > .toc a');
        var last = 0;
        var flag = 0;

        $(window).on('scroll', function(eventObj){
            _set_item();
        });

        function set_item(){
            var top = $(window).scrollTop();
            if(top < anchor_list[0]){
                item.eq(last).css({backgroundColor: '', color: '#0184b7'});
                last = 0;
                return;
            }

            for(var i = 0, l = anchor_list.length; i < l; i++){
                if(top < anchor_list[i]){break}
                flag = i;
            }
            item.eq(last).css({backgroundColor: '', color: '#0184b7'});
            item.eq(flag).css({backgroundColor: '#ddd', color: '#333'});
            last = flag;
        }

        var timer = null;
        function _set_item(){
            if(timer){
                clearTimeout(timer);
            }
            timer = setTimeout(set_item, 100);
        }
    }

    function create_toc(){
        if($('body.z > .content > .toc').length == 0){
            $('body.z > .content > .header').css('min-height', '200px');
            return;
        }
        if($('body.z > .content > .toc').height() < 50){return}

        //至少200空间
        var space = ($(window).width() - $('body.z > .content').outerWidth());
        if( space < 200 ){return}

        $('body.z > .content > .header').css('min-height', '200px');

        var toc_width = (space > 400 ? 400 : space);
        var content_left = (space - toc_width - 20) / 2;

        $('body.z > .content > .toc ol').css({
            paddingLeft: '20px'
        });
        $('body.z > .content > .toc ul').css({
            paddingLeft: '20px'
        });

        $('body.z > .content').css({
            marginLeft: content_left + 'px'
        });

        $('body.z > .content > .toc').css({
            fontSize: '12px',
            width: toc_width + 'px',
            backgroundColor: 'white',
            border: '1px solid #ccc',
            boxShadow: '0 2px 5px rgba(0, 0, 0, 0.3)',
            position: 'fixed',
            zIndex: 9999,
            padding: '10px',
            boxSizing: 'border-box',
            top: '50px',
            right: content_left + 'px',
            overflow: 'auto',
            maxHeight: $(window).height() - 100 + 'px'
        });

        bind_scroll();
    }

    function is_mobile(){
        if(window.devicePixelRatio > 1 || navigator.userAgent.indexOf('Android') >= 0){
            return true;
        }
        return false;
    }

    function mobile_meta(){
        var ua=navigator.userAgent;
        var meta = '';
        if(ua.indexOf('Android')!=-1){
            var isUC= /UC /.test(ua) || /UCBrowser/.test(ua) || /baidubrowser/.test(ua)|| /qq/i.test(ua);
            if(isUC){
                meta='<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,target-densitydpi=device-dpi,user-scalable=no" />';
            } else {
                meta='<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5,target-densitydpi=320,user-scalable=no" />';
            }
        }else{
            meta='<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5,target-densitydpi=device-dpi,user-scalable=no,minimal-ui" />';
        }
        $('head').append(meta);
    }

    function mobile_adjust(){
        $('body.z > .content').css({ width: '100%', padding: '15px' });
        $('#qr').hide();
        $('#disqus_thread').css({ width: '100%' });
        $('body.z').css({ letterSpacing: 0 });
        $('body.z p, body.z ul, body.z ol').css({ lineHeight: '1.5em' });
        $('body.z ul > li, body.z ol > li').css({ textIndent: '-2em' });
        $('body.z > .content > .toc ul > li, body.z > .content > .toc ol > li').css({ textIndent: 0, margin: 0 });
        $('body.z pre').css({ whiteSpace: 'pre-wrap', wordWrap: 'break-word' });
    }

    function normal_adjust(){
        $('body.z > .content > .toc ul > li, body.z > .content > .toc ol > li').css({ textIndent: 0, margin: 0 });
    }

    function code_view(){

        $('pre').click(function(eventObj){
            var $node = $($.clone(this));
            $node.attr('style', '');
            $node.css({
                fontSize: '24px',
                fontFamily: 'monospace',
                whiteSpace: 'pre-wrap',
                wordWrap: 'break-word',
                lineHeight: '1.5em',
                width: $(window).height(),
                height: $(window).width(),
                boxSizing: 'border-box',
                padding: '10px',
                paddingBottom: '30px',
                overflow: 'hidden'
            });
            var $wrapper = $('<div></div>').css({
                position: 'fixed',
                padding: 0,
                margin: 0,
                boxSizing: 'border-box',
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                width: $(window).height(),
                height: $(window).width(),
                overflow: 'hidden',
                top: ($(window).height() - $(window).width()) / 2,
                left: ($(window).width() - $(window).height()) / 2,
                transform: 'rotate(90deg)',
                zIndex: 999999
            });

            var $close = $('<div>&times;</div>').css({
                position: 'absolute',
                right: 0,
                top: 0,
                width: '100px',
                height: '100px',
                lineHeight: '80px',
                fontSize: '80px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)'
            });

            var $up = $('<div>△</div>').css({
                position: 'absolute',
                right: 0,
                bottom: '300px',
                width: '100px',
                height: '100px',
                lineHeight: '50px',
                fontSize: '50px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)',
                userSelect: 'none',
                '-webkit-user-select': 'none'
            });

            var $down = $('<div>▽</div>').css({
                position: 'absolute',
                right: 0,
                bottom: '100px',
                width: '100px',
                height: '100px',
                lineHeight: '150px',
                fontSize: '50px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)',
                userSelect: 'none',
                '-webkit-user-select': 'none'
            });

            $wrapper.append($node);
            $wrapper.append($close);
            $wrapper.append($up);
            $wrapper.append($down);

            $wrapper.on('touchstart', function(){
                return false;
            });

            $close.on('touchstart', function(){
                $close.css({ backgroundColor: '#0184b7' });
                return false;
            });
            $close.on('touchend', function(){

                $wrapper.off('touchend');
                $close.off('touchstart');
                $close.off('touchend');
                $up.off('touchstart');
                $up.off('touchend');
                $down.off('touchstart');
                $down.off('touchend');
                $wrapper.remove();

                return false;
            });

            var up_timer = null;
            $up.on('touchstart', function(eventObj){
                var start = $node.scrollTop();
                var dx = 0;
                $up.css({ backgroundColor: '#0184b7' });
                up_timer = setInterval(function(){
                    dx += 20;
                    $node.scrollTop(start - dx);
                }, 25);
                return false;
            });
            $up.on('touchend', function(eventObj){
                if(up_timer){clearInterval(up_timer)};
                $up.css({ backgroundColor: 'rgba(204, 204, 204, 0.5)' });
                return false;
            });

            var down_timer = null;
            $down.on('touchstart', function(eventObj){
                var start = $node.scrollTop();
                var dx = 0;
                $down.css({ backgroundColor: '#0184b7' });
                down_timer = setInterval(function(){
                    dx += 20;
                    $node.scrollTop(start + dx);
                }, 25);
                return false;
            });
            $down.on('touchend', function(eventObj){
                if(down_timer){clearInterval(down_timer)};
                $down.css({ backgroundColor: 'rgba(204, 204, 204, 0.5)' });
                return false;
            });

            $(this).before($wrapper);
        });
    
    }

    if(is_mobile()){
        mobile_meta();
        mobile_adjust();
        code_view();
    } else {
        create_toc();
        normal_adjust();
    }
});
</script>
    

    <div style="padding: 4px; line-height: 1.4em; font-size: 22px; margin-top: 100px; margin-bottom: 20px; clear: both; text-align: center; font-weight: bold; ">评论</div>
<div id="disqus_thread" style="width: 800px; margin: auto; "></div>
<script type="text/javascript">
  var disqus_shortname = 'zys';
  var disqus_identifier = 'rabbitmq';
  var disqus_url = 'https://www.zouyesheng.com/rabbitmq.html';
  var disqus_title = 'RabbitMQ 使用参考';

  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>评论功能需要javascript的支持</noscript>
    

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-29492100-1', {siteSpeedSampleRate: 100});
ga('require', 'linkid');
ga('set', 'dimension1', (new Date()).getDay().toString());
ga('send', 'pageview');
</script>
    

<div id="qr" style="position: absolute; right: 30px; top: 80px;"><img style="border: 1px solid gray;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKUAAAClAQAAAAAVUAB3AAABkElEQVR4nN2XQW4bMQxFHx0D8k5z
A/ki9eRaAQxYRg30WB0lF5m5gbKTAWV+F9Ns0izDAi134oIE+f8nKRN/2n33iRP+PW8xs0Ox/YIs
Y2Z2dMxmkjDldCBmgtT9akOlksIaNUOUwsQ5Nef+Wr0eOb3uvzru595nSKHUp6N7tqgZWQcNwKjs
mU1mhlXgpcLdbO/JEknSFCWskiRJjiwplpcDXI+aYl5sx9VPb2iNmtuoTjvFnBiVPRXwsmTiT8vb
u8l81S3NbYOsQiieuKFSLwoTl5mxnlOQul8n0Rp70splbsQMY8UTN6s/ZttxS4z1QSi54jbFvhFT
pZ5p5qu302uQPXI9Qtynw7fhzVNvkqSinppVCCuuuJXhzQ7aBgo0892mUk9tVE6hSHMbffU2bavt
MjOqA/G7Z7b3HTBj6kmulwKagLDyoHbinELxnCW/b67n2JdQ6o2m4fYXbq6MijKYb20A2NLT/RFo
Gr4y7kfbaivqYBVUPLcpKpLCBIlRmUb01hub3kzdmZP2H/+ofgEyDxWyRSRwZQAAAABJRU5ErkJg
gg==
" title="本文二维码网址" /></div>
    

<div style="font-size: 10px; text-align: right; margin-top: 50px; letter-spacing: 0;">
&copy;2010-2016 zouyesheng.com All rights reserved. Powered by <a href="https://github.com/" target="_blank">GitHub</a> , <a href="http://txt2tags.org/" target="_blank">txt2tags</a> , <a href="https://www.mathjax.org/" target="_blank">MathJax</a>
</div>
    
<!-- xhtml code generated by txt2tags 2.6 (http://txt2tags.org) -->
</div></body></html>
