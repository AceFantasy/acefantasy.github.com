Erlang学习笔记
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --prettyprint --google-analytics --disqus --mathfax 
%%toc


=数据类型=

==整数==

```
−234 0 10 100000000
2#1010 −16#EA
```

ASCII 字符可以当整数用：

```
$a
$b
$\n
```


==浮点数==

```
17.368 −56.654 1.234E-10
```


==原子==

类似于静态量的类型。

如果以小写字母开头，则可以使用字母，数字， //@// ， //.// ， //_// ：

```
january fooBar alfa21 start_with_lower_case node@ramone true false
```

如果直接以单引号包起来，则可以使用任意的字符：

```
'January' 'a space' 'Anything inside quotes{}#@ \n\012'
'node@ramone.erlang-consulting.com'
```


==布尔量==

Erlang 中没有单独的布尔类型，使用原子 //true// 和 //false// 来代替使用：

```
true false
```


==元组==

各种成员的组合就是元组，使用大括号包起来，各成员以逗号分割：

```
{123, bcd} {123, def, abc} {abc, {def, 123}, ghi} {}
{person, 'Joe', 'Armstrong'} {person, 'Mike', 'Williams'}
```


==列表==

各种成员的有序组合是列表，使用中括号包起来，各成员以逗号分割：

```
[january, february, march]
[123, def, abc]
[a,[b,[c,d,e],f], g]
[]
[{person, 'Joe', 'Armstrong'}, {person, 'Robert', 'Virding'}, {person, 'Mike', 'Williams'}]
[72,101,108,108,111,32,87,111,114,108,100]
[$H,$e,$l,$l,$o,$ ,$W,$o,$r,$l,$d]
"Hello World"
```


==字符串==

字符串实际上就是整数列表，或者反过来说整数列表就是字符串(至少 ASCII 范围内)：

```
1> "孤高天使".
[23396,39640,22825,20351]

2> [64,64,64,64].
"@@@@"
```

=运算符=

==算术运算符==

| + | 加(正) |
| - | 减法(负) |
| * | 乘法 |
| / | 除法 |
| div | 整除 |
| rem | 求余 |


==逻辑运算符==

| and | 与 |
| or | 或 |
| not | 非 |
| andalso | 与(短路) |
| orelse | 或(短路) |
| xor | 异或 |


==比较运算符==

| == | 等于 |
| /= | 不等于 | 
| =:= | 全等 |
| =/= | 不全等 |
| =< | 等于或小于 |
| < | 小于 |
| >= | 等于或大于 |
| > | 大于 |


不同类型之间不能按值比较，只遵循以下规则：

```
number < atom < reference < fun < port < pid < tuple < list < binary
```

列表的比较根据成员的字典序进行：

```
5> [boo,hoo]<[adder,zebra,bee].
false
6> [boo,hoo]<[boo,hoo,adder,zebra,bee].
true
```

元组的比较首先比较成员个数，再按列表规则比较成员：

```
7> {boo,hoo}<{adder,zebra,bee}.
true
8> {boo,hoo}<{boo,hoo,adder,zebra,bee}.
true
```

全等会同时检查类型，它通常更快，不过用得不多：

```
1> 1.0 == 1.
true
2> 1.0 =:= 1.
false
5> 1 =/= 1.0.
true
```


=列表结构=

列表可以以一种方便的语法切割成 //head// 和 //tail// 两部分，其中 //tail// 总是一个列表(可以是空列表)：

```
List = [Element | List] or []
[1,2,3] == [1 | [2 | [3 | []]]]
```


=变量=

变量以大写字母开头，可以包含字母，数字，下划线。并且， Erlang 中某个变量只能被赋值一次，所有的变量传递都是值传递，作为函数参数时，变量先求得值再会去执行函数体。

在 Erlang shell 中可以使用 //f()// 和 //f(Var)// 取消所有或指定变量：

```
f()
f(Double)
```


=模式匹配=

Erlang 中的模式匹配机制可以做的事有：

- 变量赋值
- 分支检查
- 展开数据


当一个模式匹配被执行时：

- 如果匹配成功，则相应变量被赋值
- 如果匹配失败，则没有变量会改变


```
1> List = [1,2,3,4].
[1,2,3,4]

2> [Head|Tail] = List.
[1,2,3,4]

3> Head.
1

4> Tail.
[2,3,4]

5> [A, B, C] = [1, 2, 3]
[1,2,3]

6> A.
1

7> [A, B, D] = [1,2,4].
[1,2,4]

8> D.
4
```

复杂一点：

```
{A, _, [B|_], {B}} = {abc, 23, [22, 23], {22}}
```


其中的 //_// 表示无关量，它可以当变量用，但永远不会被赋值，也就可以重复用了。


//模块与函数//

之所有把函数和模块放到一起说，是因为在 Erlang shell 中是无法直接定义一个函数的，你必须地单独的文件中定义函数，然后在 shell 中编译它，之后才能使用。

模块文件的文件名使用 //.erl// 作为扩展名，并且文件名要和模块名相同，比如 //demo.erl// ：

```
-module(demo).
-export([double/1]).

%This is a comment.

double(Value) -> times(Value, 2).
times(X, Y) -> X * Y.
```

之后在 shell 中先使用 //cd()// 到达指定目录，就可以编译这个模块了：

```
> cd('xxx').
> c(demo).
{ok,demo}
> demo:double(10).
20
```

模块文件中可以有一些使用 //-// 开头的选项，比如我们之前已经看到的：

```
-module(demo).
-export([double/1]).
```

其它的比如还有： //import// 导入函数：

```
-import(math, [sqrt/1]).
hello(X) -> sqrt(X).
```

也可以使用任意的自定义选项，不过这些选项只能有一个参数，比如：

```
-author(zys).
-date(Date).
```

模块的详细信息可以使用它的 //module_info/1// 函数获取：

```
demo:module_info().
```

模块的 //vsn// 属性是它的版本标识，如果不指定，则自动以当前文件内容的 MD5 值来填充。


