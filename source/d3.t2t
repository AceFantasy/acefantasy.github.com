D3学习笔记
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/d3.html
%!format: !email
%%toc


# 第一印象 #

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>D3</title>
    <script type="text/javascript" src="http://s.zys.me/js/jq/jquery.min.js"></script>
    <script type="text/javascript" src="http://s.zys.me/js/d3/d3.min.js"></script>
  </head>
  <body>
    <script type="text/javascript">
      $(function(){
        d3.select('body').append('div').text('Hello D3');
      });
    </script>
  </body>
</html>
```


*D3* 是一套专注于数据可视化处理的工具 https://d3js.org/，链式调用风格配合数据绑定后的向量化操作（vectorized operation）巧妙地实现数据与表现的衔接。

- 链式调用，类似于 jQuery 的选择器方法，代码写出来是一连串的点点点……
- 数据绑定，准确地说其实不算是“绑定”行为，只是在调用时把“数据”与“选择”关联起来，同时 d3 的 api 提供了对这两者之间的差异的处理途径。
- 向量化操作，这点和上面的“数据绑定”是一起的，许多用于数据处理的工具都有类似的机制（比如 Python 的 Pandas http://pandas.pydata.org/），简单来说这个机制可以让你简单地直接处理一个数据集，而不用自己手工再去遍历一次。就像 jQuery 那种直接把后续操作（比如设置样式）作用到当前选择的多个节点上。


d3 的 api 看起来很多，但我觉得核心的东西就是上面三点，其它的，全是为处理数据和展示数据的方便所提供的工具，比如对 svg 的支持，一个数据集与另一个数据集之间的映射，颜色处理工具，等。



# 核心形式 #

## 选择与链式调用 ##

数据展现离不开对 DOM 的操作，这方面 d3 跟 jQuery 比较相似。

``d3.select() / d3.selectAll()`` ：选择符合条件的第一个或全部节点。参数可以直接是节点，或者选择器表达式。比如：

```javascript
d3.select('body');
d3.selectAll('div.circle');
d3.select($('div.wrapper').find('.rectangle')[0]);
```

如果使用 jQuery 的话注意 jQuery 对象与 DOM 节点之间的转换。

``d3.select()`` 的返回值，可以继续被 ``select() / selectAll()`` ：

对于：

```html
<div class="out">
    <div class="in"></div>
    <div class="in"></div>
    <div class="in"></div>
    <div class="in"></div>
</div>
```

可以：

```javascript
d3.select('div.out').selectAll('div.in');
```

选择之后可以跟 jQuery 一样，对节点进行各种样式，属性，内容等的处理：

- ``selection.attr()`` 节点属性。
- ``selection.classed()`` 节点类。
- ``selection.style()`` 节点样式。
- ``selection.property()`` “内属性”。
- ``selection.text() / selection.html()`` 节点内容。
- ``selection.append() selection.remove()`` 添加 / 删除节点。



``classed()`` 的使用：

```javascript
d3.select('body').classed('a b', true);
d3.select('body').classed({a: true, b: false});
```

``style()`` 的使用：

```javascript
d3.select('body').style('background-color', 'red');
d3.select('body').style({'background-color': 'red', height: '200px'});
```

注意，在设置样式时， d3 不像 jQuery 那么智能，知道在 *background-color* 与 *backgroundColor* 之间转换。同时，对于样式值的处理， d3 也不会自己加上 *px* 这种合适的单位。

另外，d3 的选择的结果是一个二维结构：

```html
<div class="action">
  <button id="btn-a">三个</button>
  <button id="btn-b">二个</button>

  <div class="wrapper">
    <div class="item">1</div>
    <div class="item">2</div>
  </div>
</div>

<div class="wrapper">
  <div class="item">1</div>
  <div class="item">2</div>
  <div class="item">3</div>
  <div class="item">4</div>
</div>
```

对上面的页面，使用：

```javascript
var query = d3.selectAll('div.wrapper').selectAll('.item');
console.log(query);
```

会看到 ``[ [node, node], [node, node, node, node] ]`` 这种结构的输出。



## 数据绑定与变化 ##


d3 的选择结果，可以通过 ``data()`` 方法映射一个数据集，映射之后，选择与数据的差异作为结果返回。这个差异里，有可能是“选择有，但是数据没有”的多余节点，也可能是“选择没有，但是数据有”的空节点占位符。

看一个完整的例子：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>D3</title>
    <script type="text/javascript" src="http://s.zys.me/js/jq/jquery.min.js"></script>
    <script type="text/javascript" src="http://s.zys.me/js/d3/d3.min.js"></script>
  </head>
  <body>

    <div class="action">
      <button id="btn-a">三个</button>
      <button id="btn-b">二个</button>
    </div>
    <div class="wrapper"></div>

    <script type="text/javascript">
      $(function(){

        function test(item){
          var query = d3.select('div.wrapper').selectAll('.item');
          var bind = query.data(item);
          //var bind = query.data(item, function(d){ return d });
          bind.enter().append('div').classed('item', true).text(function(d, i){return d});
          bind.exit().remove();
        }

        $('#btn-a').click(function(){
          test(['A', 'B', 'C']);
          d3.select('div.wrapper').selectAll('.item')
            .each(function(){ $(this).attr('data-d3', this.__data__)});
        });

        $('#btn-b').click(function(){
          test(['B', 'C']);
          d3.select('div.wrapper').selectAll('.item')
            .each(function(){ $(this).attr('data-d3', this.__data__)});
        });


      });
    </script>
  </body>
</html>
```

上面的例子，在点击“三个”按钮之后，会看到“A，B，C”的结果。

但是，点击“二个”按钮，看到的结果是“A，B”，不是“B，C”。除非使用注释掉的这句：

```javascript
//var bind = query.data(item, function(d){ return d });
```

这其中的原因，在于 d3 对于是否传入了第二个函数参数，本来就有不同的处理逻辑。

首先， ``data()`` 方法的第一个参数，可以传入一个列表，或者一个会返回列表的回调函数。如果是一个函数，则这个函数接收的参数是当前选择的节点集的父节点的 ``__data__`` 属性值，及序号：

```html
<div class="wrapper">
    <div class="item">1</div>
    <div class="item">2</div>
</div>
```

```javascript
d3.select('div.wrapper').data(['X', 'Y']);
var query = d3.select('div.wrapper').selectAll('.item');
query.data(function(d, i){
    console.log(d, i);
    return [];
});
```

上面会输出： ``X 0`` 的结果。

这里提到的 ``__data__`` 属性值，就是在 ``data()`` 方法调用之后，节点中绑定的数据（放在节点的 ``__data__`` 属性）。

看到 ``data()`` 方法的调用时，始终要留意考虑两方面的东西，一方面是当前选择的节点集（及这些节点集的 ``__data__`` 状态），另一方面是 ``data()`` 方法调用时传入的数据。

``data()`` 调用之后：

- 本身后续得到的是 *匹配节点* ，表示这些节点的 ``__data__`` 属性更新了。
- ``enter()`` 得到 *新增节点* （的占位符），表示这些节点在数据中，但是不在当前选择中。
- ``exit()`` 得到 *删除节点* （多余的），表示这些节点不在数据中，但在当前选择中（是否删除在于你怎么处理了）。


关于 *匹配节点* 看一个列子：

```html
<div class="wrapper">
    <div class="item">1</div>
    <div class="item">2</div>
    <div class="item">3</div>
    <div class="item">4</div>
</div>
```

```javascript
d3.select('div.wrapper').selectAll('.item')
    .data(['A', 'B'])
    .style('color', 'red')
    .each(
        function(){
            $(this).attr('data-d3', this.__data__);
        }
    );
```

结果就是 ``1`` 和 ``2`` 变成红色。随便再把 ``__data__`` 属性放出来看看。

注意，前面说过， ``selectAll()`` 结果是二维的， ``data()`` 传入的数据是一维的（即使形式是多维，它的作用也只是一维），所以 ``data()`` 传入的数据是会在当前的所有选择集上遍历作用一次的。


---------------------------


当调用 ``data()`` 方法没有传第二个函数参数时：

- 按序号对应关系，节点的 ``__data__`` 设置为相应的数据。
- 所以 *匹配节点* 是前 N 个， N 为当前选择节点个数与传入数据个数的小者。
- 如果有多出来的数据，作为 *新增节点* ， ``enter()`` 的结果。
- 如果有多出来的节点，作为 *删除节点* ， ``exit()`` 的结果。


所以刚才先点击“三个”按钮，再点击“二个”按钮，发生的事是：

- 点“三个”按钮时，当前选择节点为空，于是会有三个 *新增节点* ，依次绑定的数据是 ``A, B, C`` 。
- 再点“二个”按钮时，当前选择是三个绑定了数据的节点，但是只有两个数据传入，于是第三个节点被作为 *删除节点* ， ``bind.exit().remove()`` 会把它删除掉，就完了，这里没有涉及任何数据的表现上的更新。所以页面上还显示 ``A, B`` ，虽然，前两个节点的绑定数据，已经从 ``A, B`` 变成 ``B, C`` 了。（看节点属性的 ``data-d3`` 能看到）。


我们把代码改一下：

```javascript
$('#btn-b').click(function(){
    test(['B', 'C']);
    d3.select('div.wrapper').selectAll('.item').text(function(d, i){return d});
});
```

在后面多加一个 ``text()`` 调用，就可以把页面显示改成 ``B, C`` 了。


---------------------------


如果调用 ``data()`` 方法，传了第二个函数参数（ *key 函数* ， ``function(data, index){}``），问题会复杂一点点。从上面的简单的扁平结构按长度出差异，要变成一个映射结构，来判断键值存在与否得出差异。

- 第一步，根据当前选择的节点集，生成一个节点索引，键值由 *key 函数* 得出，传入的 ``data`` 为节点当前 ``__data__`` （如果键值有重复的，则作为 *删除节点* 处理）。
- 第二步，遍历传入的数据的对应键值（把数据传入 *key 函数*），如果这些键值存在节点索引中，则作为 *匹配节点* 处理，更新 ``__data__`` ，不在节点索引中，则作为 *新增节点* 处理。同时这部分命中的索引会做出标记。
- 第三步，遍历当前选择的节点集，根据对应的索引键值，在第二步命令中之外的节点，作为 *删除节点* 处理。


如果我们使用：

```javascript
var bind = query.data(item, function(d){ return d });
```

那么先点“三个”按钮，再点“二个”按钮的流程就变成了：

- 点“三个”按钮时，当前选择节点为空，于是会有三个 *新增节点* ，依次绑定的数据是 ``A, B, C`` 。
- 点“二个”按钮时，因为页面上有三点绑定了数据的节点，根据传入的函数，先生成的节点索引为 ``{A: none, B: node, C: node}`` 。
- 传入数据是 ``['B', 'C']`` ，对于的键值也就是 ``['B', 'C']`` ，所以后两个节点定为 *匹配节点* 处理了。
- 最后遍历当前选择的三个节点，会发现第一个节点对应的键值不在索引中，于是按 *删除节点* 处理。执行 ``bind.exit().remove()`` 后被删除。


最后我们就在页面上看到剩下的 ``B, C`` 了。


---------------------------


前面说了传入的 *key 函数* 用于索引键值的计算，这里注意一下，“键值”与“绑定的数据”，是两个东西（只是前面的例子，它们“碰巧”一样而已）。

把前面的代码稍作修正：

```javascript
function test(item){
    var query = d3.select('div.wrapper').selectAll('.item');
    //var bind = query.data(item);
    var bind = query.data(item, function(d, i){ return i });  // <-----
    bind.enter().append('div').classed('item', true).text(function(d, i){return d});
    bind.exit().remove();
}

$('#btn-a').click(function(){
    test(['A', 'B', 'C']);
    d3.select('div.wrapper').selectAll('.item').each(function(){ $(this).attr('data-d3', this.__data__)});
});

$('#btn-b').click(function(){
    test(['X', 'Y']);
    d3.select('div.wrapper').selectAll('.item').each(function(){ $(this).attr('data-d3', this.__data__)});
});
```

先点“三个”按钮，再点“二个”按钮，最后显示的是 ``A, B`` 了。内容传的是 ``X, Y`` ，但是内容并不影响 *key 函数*的返回（它的返回值是序号嘛）。

注意，跟之前一样，虽然当前显示的是 ``A, B`` 了，但是，实际上两个节点绑定的数据已经变成 ``X, Y`` 了。



## 多维数据的绑定与展开 ##

先把前面提过的，也许不起眼的两句话列出来：

- ``data()`` 传入的数据是一维的（即使形式是多维，它的作用也只是一维）。
- ``data()`` 方法的第一个参数，可以传入一个列表，或者一个会返回列表的回调函数。如果是一个函数，则这个函数接收的参数是当前选择的节点集的父节点的 ``__data__`` 属性值，及序号。


假设我们有一个三维的数据：

```javascript
var info = [
    [
        { name: zys, url: www.zouyesheng.com },
        { name: google, url: google.com },
        { name: taobao, url: www.taobao.com },
    ],
    [
        { name: zys, url: www.zouyesheng.com },
        { name: google, url: google.com },
        { name: taobao, url: www.taobao.com },
    ]
];
```

要如何绑定展示出来呢，比如要放到 2 个表格中，表格有 name 和 url 两列。

直观地我们能想到：

```javascript
d3.selectAll('table').data(info).enter().append('table');
d3.selectAll('table').selectAll('tr') ... ...
```

接下来呢？

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>D3</title>
    <script type="text/javascript" src="http://s.zys.me/js/jq/jquery.min.js"></script>
    <script type="text/javascript" src="http://s.zys.me/js/d3/d3.js"></script>
  </head>
  <body>

    <script type="text/javascript">
      $(function(){
        var info = [
          [
            { name: 'zys', url: 'www.zouyesheng.com' },
            { name: 'google', url: 'google.com' },
            { name: 'taobao', url: 'www.taobao.com' }
          ],
          [
            { name: 'zys', url: 'www.zouyesheng.com' },
            { name: 'google', url: 'google.com' },
            { name: 'taobao', url: 'www.taobao.com' }
          ]
        ];

        var table = d3.select('body').selectAll('table')
        .data(info).enter().append('table');

        var tr = table.selectAll('tr')
        .data(function(parent){ return parent }).enter().append('tr');

        var td = tr.selectAll('td')
        .data(function(parent){ return [parent.name, parent.url] }).enter().append('td').text(function(d){return d});

        table.style({
          margin: '10px',
          'border-collapse': 'collapse'
        });

        td.style({
          border: '1px solid #ccc',
          padding: '5px'
        });

      });
    </script>
  </body>
</html>
```

``data()`` 的数据形式可以是一个回调函数，这个回调函数接收的是父级节点的 ``__data__`` ，而我们在绑定数据的时候，数据的形式是没有限制的。所以父节点中可以保存足够复制的数据来供给子节点进一步的展开。只需要记住，这个回调函数需要返回一个列表就可以了。

（突然想到，这个回调函数是不支持异步的，但愿不会碰到这种需求吧）

看上面的代码，多维的展开这点不论， ``table`` ， ``td`` 这种 ``selectAll()`` 的结果先保存下来，最后再指定处理它们的样式，这种方式也非常漂亮。



# 动画效果 #


## 基本使用 ##


动画， *transition* ，是 d3 中我觉得很赞的一块东西，特别是跟 ``data()`` 的 ``enter()`` 和 ``exit()`` 配合起来使用时。

``transition()`` 的基本使用方法类似 jQuery 的 ``animate()``  ，给出目标样式，中间的补间动画效果会自动处理。

```javascript
$(function(){
  d3.select('body').append('div')
  .style({
    width: '100px',
    height: '100px',
    'background-color': 'red',
    'margin-left': '0'
  })
  .transition()
  .delay(1000)
  .duration(2000)
  .style({
    'margin-left': '300px'
  });
});
```

上面的代码效果是，一个红色方块，在 1 秒种之后，会花 2 秒时间从左边移动到右边。

``transition()`` 调用之后，后续会有一些方法来控制动画的一些细节：

- ``transition([name])`` 声明动画的时候是可以指定名字的，这样可以为同一目标设置多组不同名的动画。
- ``duration()`` 指定动画的时间，默认是 250 毫秒。
- ``delay()`` 播放前的延迟时间，默认是 0 。
- ``tween()`` 自定义补间动画的实现函数。
- ``ease()`` 指定“变化模型”的函数，默认是 *cubicInOut*。



## transition() ##


先说，``transition([name])`` 。如果你想对于同一个节点，有多个动画一个接一个地发生的话，可以简单地串连调用 ``transition()`` 就可以了：

```javascript
var query = d3.select('body').append('div')
.style({
  width: '100px',
  height: '100px',
  'background-color': 'red',
  'margin-left': '0',
  'margin-top': '0'
});

query
.transition()
.delay(500)
.duration(2000)
.style({
  'margin-left': '300px'
}).transition()
.duration(2500)
.style({
  'margin-top': '300px'
})
;
```

但是如果想让多个动画效果同时发生，那么除了对选择对象多次应用 ``transition()`` 之外，还有指定不同的名字。

不指定名字：

```javascript
query
.transition()
.delay(500)
.duration(2000)
.style({
  'margin-left': '300px'
});

query
.transition()
.duration(2500)
.style({
  'margin-top': '300px'
});
```

这样是不行的，后定义的会覆盖先前定义的，所以结果就是方块只会往下移，而不会向右移动了。

多次调用 ``transition()`` 时指定不同名字：

```javascript
query
.transition('x')
.delay(500)
.duration(2000)
.style({
  'margin-left': '300px'
});

query
.transition('y')
.duration(2500)
.style({
  'margin-top': '300px'
});
```

指定名字之后，右移和下移的行为就会同时执行，看起来方块的移动路径就像是一条弧线。

跟 ``transition()`` 相关的其它一些 api ，也是支持传入一个 ``name`` 用来指定名字的，比如 ``tween([name])`` 。


## tween() ##


现在来说 ``tween()`` ，这个是用来自定义补间动画实现的，你可以认为 ``style()`` 样式上动画效果的自动实现，只是 d3 官方预先使用 ``tween()`` 做了一些事而已。

```javascript
var query = d3.select('body').append('div')
.style({
  width: '100px',
  height: '100px',
  'background-color': 'red',
  'margin-left': '0',
  'margin-top': '0'
});

query
.transition()
.delay(500)
.duration(2000)
.style({
  'margin-left': '300px'
}).
tween('', function(d, i){
  var that = this;
  return function(t){
    $(that).text(t);
  }
});
```

上面的代码能在方块移动过程中看到里面文本的变化。从中看 ``tween()`` 的调用方法，第一个参数是一个名字，不能省略。第二个参数是一个返回函数的函数，它本身接收的参数是当前节点绑定的数据（ ``data()`` 方法），返回的函数，其接收的参数是一个“时间位置”，取值范围 ``[0, 1]`` 。


## ease() ##


最后说一下 ``ease()`` ，它是用来指定一个关于“位置-时间”的函数的方法，“位置-时间”的函数，表现出来可以是移动速度的快慢，位置回弹等，这些关系通过一个曲线很容易看出来， http://www.timotheegroleau.com/Flash/experiments/easing_function_generator.htm 这里有一个专门生成这类函数的在线工具。


注意，这部分是我自己根据执行效果的理解，并不是解读源码得出的结论。


``ease()`` 方法可以接收一个函数定义，这个函数接收一个参数 ``t`` ，返回一个新的 ``t'`` 。 对于这个 ``t`` ，可以理解成是整个动画过程的匀速等分快照，换句话说，这个动画的所有纸片已经制作完成，而现在交由我们来处理的这个 ``ease()`` 方法，其作用就是控制播放这个已完成的动画纸片的。

举个例子，假设我们要把一个方块，花 10 秒的时间从 0 的位置，向右移动到 100 的位置。那么按匀速条件，我们可以知道第 0 秒时，位置是 0 ，第 1 秒时，位置是 10 ，以此类推，我们就可以得到每秒时刻这个方块的位置，就是 ``[0, 0], [1, 10], [2, 20], [3, 30], [4, 40], [5, 50], [6, 60], [7, 70], [8, 80], [9, 90], [10, 100]`` 。把这每个“时刻-位置”对相像成一张纸。现在联想一下动画的原理，假设我们以 1 秒为周期（1 秒 1 帧），每过 1 秒，我就向你要一张纸，而给我哪张纸就是 ``ease()`` 方法中的函数做的事。

从第 0 秒开始：

- 给我 0 秒纸， ``[10, 100]``
- 给我 1 秒纸， ``[9, 90]``
- 给我 2 秒纸， ``[8, 80]``
- ...


现在过了 3 秒，那根据给的纸的效果，连续起来，我们看到的就是一个倒播的效果，位置变化是 ``100, 90, 80`` 嘛。

回到 ``ease()`` 接收的函数中的那个 ``t`` 参数。我们的例子是在具体的 10 秒时间内，向右移动 100 个单位。把时间与运动状态作一般化处理，我们可以把上面的纸片看成是在某个时刻的具体状态， ``[t1, s1], [t2, s2], [t3, s3]，... [tn, sn]`` 。现在我们只要定一个每秒帧数，就可以把这些纸片全部确定下来。然后时间一般化处理成 ``0 ~ 1`` ，同样的例子，比如我们定每秒 10 帧， 10 秒就有 100 帧， ``0 ~ 1`` 分成 100 份就是 ``0.01`` 的间隔。

```javascript
ease(function(t){});
```

``function(t){}`` 中的 ``t`` 参数，就是这个 ``0 ~ 1`` 的一般化后的时刻。而我们要返回的东西，也是一个时刻，事实上这个时刻就是代表其对应的那张纸片了。


考虑：

```javascript
function(t){ return 1 - t; }
```

这样的一个函数实现。

- 第 0 时刻时，得到的是 ``1 - 0 = 1`` 这个时刻标记的卡片，也就是位置在 100 上。
- 第 0.01 时刻时，得到的是 ``1 - 0.01 = 0.99`` 这个时刻标记的卡片，也就是位置在 99 上。
- 第 0.02 时刻时，得到的是 ``1 - 0.02 = 0.98`` 这个时刻标记的卡片，也就是位置在 98 上。
- ...


所以， ``ease(function(t){ return 1 - t })`` 就是一个“倒播”的效果。


```javascript
var query = d3.select('body').append('div')
.style({
  width: '100px',
  height: '100px',
  'background-color': 'red',
  'margin-left': '0',
  'margin-top': '0'
});

query
.transition()
.delay(500)
.duration(2000)
.ease(function(t){
  return 1 - t;
})
.style({
  'margin-left': '800px'
});
```

对于 ``function(t){}`` 这个函数的实现，很自然地就可以理解：

- ``t`` 是一个匀速的正向运动。
- ``1 - t`` 是匀速逆向运动。
- ``t * t`` 是加速运动。
- ``if (t < 0.5) {return t} else { return 1 }`` 就是匀速运动一半之后，突然就直接到达终点了。


当然，你还可以实现很复杂的效果，什么弹性模拟，现实的物理碰撞模拟等。

d3 的实现中， ``ease()`` 方法不光能接收一个 ``function(t){}`` 函数，它还可以直接指定使用 d3 中已经实现的一些变化效果，比如：

```javascript
ease('linear');
ease('poly', '3');
ease('elastic', '2', '0.5')
```

第一个参数是已实现的函数名，后面的参数是对应函数需要的参数，已实现的有 https://github.com/mbostock/d3/wiki/Transitions#d3_ease：

```text
- linear - the identity function, t.
- poly(k) - raises t to the specified power k (e.g., 3).
- quad - equivalent to poly(2).
- cubic - equivalent to poly(3).
- sin - applies the trigonometric function sin.
- exp - raises 2 to a power based on t.
- circle - the quarter circle.
- elastic(a, p) - simulates an elastic band; may extend slightly beyond 0 and 1.
- back(s) - simulates backing into a parking space.
- bounce - simulates a bouncy collision.
```



