jQuery学习笔记
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --prettyprint --google-analytics --disqus
%%toc


原文发于2010年11月，先把旧文重新排过来，计划近期会修订此文。

=jQuery 是如何工作的=

==开始使用jQuery==

jQuery 本身只有一个 js 文件，所以，要使用它，就和使用其它的 js 文件一样，直接将它引入就可以使用了。

```
<script type="text/javascript" src="jquery-1.4.2.js"></script>
```

但是，要注意一点，因为 jQuery 大部分功能需要根据文档的 DOM 模型来工作，所以，它首先需要正确地解析到整个文档的 DOM 模型结构。为此，一般，我们使用 jQuery 所做的工作都需要在整个文档被浏览器完全加载完毕后才开始进行：

```
<script>
$(document).ready(function(){
  alert('Hello World!');
  $("p").click(function(event){
    alert('Thanks for visiting!');
  });
});
</script>
```

//$// 是在 jQuery 中被定义的一个函数，它可以简单方便地取到相关结点。 //$(document).ready// 是一个事件绑定，这在文档加载完毕后被调用。

事实上 //$()// 等于 //jQuery()// 即 jQuery 的核心函数的一个简写。

之后的 javascript 代码，都默认是写在 //$(document).ready// 这个事件绑定当中的。

当然， //$(document).ready()// 可以简写成 //$()// 。

前面说了， //$// 是一个在 jQuery 中被使用了的一个变量名，如果因为某些原因，你不能让 jQuery 使用它，那么你可以使用 //jQuery.noConflict()// 做到这一点，它的返回值就是 jQuery 这个对象。

```
jQuery.noConflict();
$j = jQuery.noConflict();
```



==jQuery对象与DOM对象之间的转换==

通常，使用 //$()// 得到的是一个 jQuery 对象。它封装了很多 DOM 对象的操作，但是，它和 DOM 对象之间是不同的。比如，如果你要使用 //obj.innerHTML// ，那只有当 //obj// 是一个 DOM 对象时才能用，相应地，如果是 jQuery 对象你应该使用 //obj.html()// 。

从 DOM 对象转到 jQuery 对象： //$(obj)// 。

从 jQuery 对象转到 DOM 对象： //obj[0]// 。

比较正规地从 jQuery 对象到 DOM 的转换，是使用 jQuery 对象的 //get()// 方法：

```
<ul>
  <li id="foo">foo</li>
  <li id="bar">bar</li>
</ul>

$('li').get();
//[<li id="foo">, <li id="bar">]

$('li').get(0);
//<li id="foo">

$('li').get(-1);
//<li id="bar">
```



=丰富的选择器=

完整的列表在 http://api.jquery.com/category/selectors/ 。


==常规选择器==

: //$("*")//
    选择所有结点
: //(“#id”)//
    ID选择器，注意其中的一些特殊字符，比如 **.**
: //(“.class”)//
    类选择器
: //(“tag”)//
    按标签选择
: //(“ancestor descendant”)//
    选择子元素
: //(“parent > child”)//
    选择直接子元素
: //:focus//
    获取焦点元素
: //:first-child// //:last-child//
    选择第一个/最后一个子元素
: //:first// //:last//
    截取第一个/最后一个符合条件的元素
: //(“prev + next”)//
    直接兄弟元素
: //(“prev ~ siblings”)//
    兄弟元素
: //:nth-child()//
    索引选择，索引从 1 开始 //:nth-child(odd)// //:nth-child(even)// //:nth-child(4n)//


==属性选择器==

: //[name~="value"]//
    属性中包括某单词
: //[name="value"]//
    属性完全等于指定值
: //[name!="value"]//
    属性不等于指定值
: //[name]//
    包括有指定属性的元素


==控件选择器==

: //:checked//
    选择所有被中的元素
: //:selected//
    被选择了的元素
: //:disabled// //:enabled//
    选择被禁用/未禁用的元素
: //:hidden//
    选择隐藏元素，不仅是 //[type="hidden"]// ，还有 //display: none//
: //:visible//
    可见控件， //visibility: hidden// 和 //opacity: 0// 同样被认为是可见。

: //:input// //:button// //:checkbox// //:file// //:image// //:password// //:radio// //:reset// //:submit// //:text//
    具体控件，图像控件是 //[type="image"]//


==其它选择器==

: //[name="value"][name2="value2"]//
    多个 AND 条件
: //(“selector1, selector2, selectorN”)//
    多个 OR 条件
: //:not()//
    否定选择
: //(':contains("text")')//
    包含有指定内容的元素
: //:eq()// //:lt()// //:gt()// //:even// //:odd//
    列表索引选择（不支持负数）
: //(':has(selector)')//
    符合条件的再次过滤
: //:header//
    选择像 h1,h2,h3 这些标题元素
: //:only-child//
    仅有一个子元素的元素
: //:empty//
    空元素，即无内容也无子元素
: //:parent//
    非空元素


=节点漫游=

完整列表在 http://api.jquery.com/category/traversing/

通过上面的选择器，我们可以得到希望处理的节点。但是通常，我们还希望得到当前节点的一些相对节点，以便下一步处理，比如“所有子节点”，“下一个兄弟节点”之类的东西。

==调用链处理==

: //.add()//
    向已有的节点序列中添加新的对象
: //.andSelf()//
    在调用链中，随时加入原始序列
: //.eq()//
    指定索引选取节点， **支持负数** 
: //.filter()// //.is()// //.not()//
    序列选择
: //.end()//
    链点回溯
```
<ul class="first">
   <li class="foo">list item 1</li>
   <li>list item 2</li>
   <li class="bar">list item 3</li>
</ul>
<ul class="second">
   <li class="foo">list item 1</li>
   <li>list item 2</li>
   <li class="bar">list item 3</li>
</ul>

$('ul.first').find('.foo').css('background-color', 'red')
  .end().find('.bar').css('background-color', 'green');
```


==子节点==

: //.children()//
    所有的子节点，可加入过滤条件， //.children(selector)//
: //.find()// //.first()// //.last()// //.has()//
    子节点选择


==兄弟节点==

: //.siblings()// //.next()// //.nextAll()// //.nextUntil()// //.prev()// //.prevAll()// //.prevUntil()// //.closest()//
    兄弟节点选择


==父节点==

: //.parent()// //.parents()// //.parentUntil()//
    父节点选择


=元素控制相关=

==attributes和properties的区别==

//attributes// 是 XML 结构中的属性节点概念范畴：

```
<body onload="prettyPrint()""></body>
```

上面的代码表示了 //body// 这个节点，有一个名为 //onload// 的 //attributes// 。

//properties// 则是对于 DOM 对象的，对象属性概念范畴。这一般就没有直观的表现，但是它总是可以被访问到的，比如：

```
$('body').get(0).tagName;
//BODY
```

虽然 //attributes// 与 //properties// 是不同的概念范畴，但是它们对于某些特殊的属性是有共同的访问属性名的，比如 //id// 。


==类与属性控制==

: //.addClass()// //.hasClass()// //.removeClass()//
    添加一个类，判断是否有指定类，删除类
```
$('body').addClass('test');
$('body').addClass(function(index, current){return current + 'new'});

$('body').removeClass('test');
$('body').removeClass(function(index, current){return current + ' ' + 'other'});
```

: //.toggleClass()//
    类的开关式转换，它的使用方法有多种：
```
<img class="test other" />

$('img').toggleClass(); //对所有类的开关
$('img').toggleClass('test'); //对指定类的开关
$('img').toggleClass(isTrue); //根据isTrue判断所有类的开关
$('img').toggleClass('test', isTrue); //根据isTrue判断指定类的开关

//同 $('img').toggleClass('test') 只是类名由函数返回
$('img').toggleClass(function(index, class, isTrue){return 'name'});

//isTrue会作为函数的第三个参数传入
$('img').toggleClass(function(index, class, isTrue){return 'name'}, isTrue);
```

: //.attr()//
    获取或者设置一个属性值，它的使用方法有多种：
```
<img id="greatphoto" src="brush-seller.jpg" alt="brush seller" />

$('#greatphoto').attr('alt'); //获取属性
$('#greatphoto').attr('alt', 'Beijing Brush Seller'); //设置属性

//同时设置多个属性
$('#greatphoto').attr({
  alt: 'Beijing Brush Seller',
  title: 'photo by Kelly Clark'
});

//设置属性为函数返回值, 函数的上下文为当前元素
$('#greatphoto').attr('title', function(i, val) {
  return val + ' - photo by Kelly Clark';
});
```
: //.prop()//
    用法同 //.attr()// ，只是对象变成了 //properties//
: //.removeAttr()// //.removeProp()//
    删除属性
: //.val()//
    设置或获取元素的表单值，通常用于表单元素。
```
<input type="hidden" value="test" />

$('input').val();
$('input').val('other');
```

: //.html()//
    设置或获取元素的节点文件本值。
```
<div><span>测试</span></div>

$('div').html();
$('div').html('<div>测试</div>');
$('div').html(function(index, old){return old + '<span>另外的内容</span>'});
```

==样式控制==

: //.css()//
    获取或设置指定的 css 样式：

```
$('body').css('background-color');
$('body').css('background-color', 'red');
$('body').css('background-color', function(index, value){return value + '1'});
$('body').css({color: 'green', 'background-color': 'red'});
```

: //.width()// //.height()//
    获取或设置元素的宽和高

```
$('body').width();
$('body').width(50);
$('body').width(function(index, value){return value += 10});
```

: //.innerWidth()// //.innerHeight()// //.outerHeight()// //.outerWidth()//
    元素的其它尺寸值

: //.scrollLeft()// //.scrollTop()//
    获取或设置滚动条的位置

: //.offset()// //.position()//
    获取元素的坐标。 //offset// 是相对于 //document// ， //position// 是相对于父级元素


==结构控制==

===文本节点===

: //.html()// //.text()//
    设置和获取节点的文值。设置时 //.text()// 会转义标签，获取时 //.text()// 会移除所有标签。


===子节点===

: //.append()// //.prepend()//
```
<h2>Greetings</h2>
<div class="container">
  <div class="inner">Hello</div>
  <div class="inner">Goodbye</div>
</div>

$('.inner').append('<p>Test</p>');

<h2>Greetings</h2>
<div class="container">
  <div class="inner">
    Hello
    <p>Test</p>
  </div>
  <div class="inner">
    Goodbye
    <p>Test</p>
  </div>
</div>
```

参数可以有多种形式：

```
var $newdiv1 = $('<div id="object1"/>'),
    newdiv2 = document.createElement('div'),
    existingdiv1 = document.getElementById('foo');

$('body').append($newdiv1, [newdiv2, existingdiv1]);
```



===兄弟节点===

: //.after()// //.before()//
```
<div class="container">
  <h2>Greetings</h2>
  <div class="inner">Hello</div>
  <div class="inner">Goodbye</div>
</div>

$('.inner').after('<p>Test</p>');

<div class="container">
  <h2>Greetings</h2>
  <div class="inner">Hello</div>
  <p>Test</p>
  <div class="inner">Goodbye</div>
  <p>Test</p>
</div>
```


===父节点===

: //.wrap()// //.wrapAll()// //.wrapInner()//

```
<div class="container">
  <div class="inner">Hello</div>
  <div class="inner">Goodbye</div>
</div>

$('.inner').wrap('<div class="new" />');

<div class="container">
  <div class="new">
    <div class="inner">Hello</div>
  </div>
  <div class="new">
    <div class="inner">Goodbye</div>
  </div>
</div>


$('.inner').wrapAll('<div class="new" />');

<div class="container">
  <div class="new">
    <div class="inner">Hello</div>
    <div class="inner">Goodbye</div>
  </div>
</div>


$('.inner').wrapInner('<div class="new" />');

<div class="container">
  <div class="inner">
    <div class="new">Hello</div>
  </div>
  <div class="inner">
    <div class="new">Goodbye</div>
  </div>
</div>
```


===复制/删除/替换节点===

: //.clone()//
    复制节点，可选参数表示是否处理已绑定的事件与数据
    : //.clone(true)//
        处理当前节点的事件与数据
    : //.clone(true, true)//
        处理当前节点及所有子节点的事件与数据
: //.detach()//
    暂时移除节点，之后可以再次恢复了指定位置。
: //.remove()//
    永久移除节点。
: //.empty()//
    清除一个节点的所有内部内容。
: //.unwrap()//
    移除节点的父节点。


=工具函数=

==jQuery对象序列==

: //.map()//
    遍历所有成员
```
$(':checkbox').map(function() {
  return this.id;
}).get().join(',');


$(':checkbox').map(function(index, node) {
  return node.id;
}).get().join(',');
```
: //.slice()//
    序列切片, 支持一个或两个参数，支持负数
```
$('li').slice(2).css('background-color', 'red');
$('li').slice(2, 4).css('background-color', 'red');
$('li').slice(-2, -1).css('background-color', 'red');
```


==通用工具==

: //$.each()// //$.map()//
    遍历列表, //$.map()// 可以作用于对象。
```
$.each([52, 97], function(index, value) { 
  alert(index + ': ' + value); 
});

$.map( [0,1,2], function(n, index){
  return n + 4;
});
//[4, 5, 6]

$.map( [0,1,2], function(n){
  return n > 0 ? n + 1 : null;
});
//[2, 3]

$.map( [0,1,2], function(n){
  return [ n, n + 1 ];
});
//[0, 1, 1, 2, 2, 3]

var dimensions = { width: 10, height: 15, length: 20 };
$.map( dimensions, function( value, key ) {
  return value * 2;
});
//[20, 30, 40] 

var dimensions = { width: 10, height: 15, length: 20 },
$.map( dimensions, function( value, key ) {
  return key;
});
//["width", "height", "length"]
```
: //$.extend()//
    合并对象，第一个参数表示是否进行递归深入
```
var object = $.extend({}, object1, object2);
var object = $.extend(true, {}, object1, object2);
```
: //$.merge()//
    合并列表
```
$.merge( [0,1,2], [2,3,4] )
//[0,1,2,2,3,4] 
```
: //$.grep()//
    过滤列表，第三个参数表示是否为取反
```
$.grep( [0,1,2], function(array,index){ return n > 0; }); //[1,2]
$.grep( [0,1,2], function(array,index){ return n > 0; }, true); //[0]
```
: //$.inArray()//
    存在判断
```
$.inArray( value, array [, fromIndex] )
```
: //$.isArray()// //$.isEmptyObject()// //$.isFunction()// //$.isNumeric()// //$.isPlainObject()// //$.isWindow()// //$.isXMLDoc()//
    类型判断
: //$.noop()//
    空函数
: //$.now()//
    当前时间戳，值为 //(new Date).getTime()//
: //$.parseJson()// //$.parseXML()//
    把字符串解析为对象
```
var xml = "<rss version='2.0'><channel><title>RSS Title</title></channel></rss>",
xmlDoc = $.parseXML( xml ),
$xml = $( xmlDoc ),
$title = $xml.find( "title" );
```
: //$.trim()//
    去头去尾， //$.trim(str)//
: //$.type()//
    判定参数的类型
```
# If the object is undefined or null, then "undefined" or "null" is returned accordingly.

* jQuery.type(undefined) === "undefined"
* jQuery.type() === "undefined"
* jQuery.type(window.notDefined) === "undefined"
* jQuery.type(null) === "null"

# If the object has an internal [[Class]] equivalent to one of the browser's built-in objects, the associated name is returned. (More details about this technique.)

* jQuery.type(true) === "boolean"
* jQuery.type(3) === "number"
* jQuery.type("test") === "string"
* jQuery.type(function(){}) === "function"
* jQuery.type([]) === "array"
* jQuery.type(new Date()) === "date"
* jQuery.type(/test/) === "regexp"
```
: //$.unique()//
    遍历后去重， //$.unique(array)//


=上下文绑定=

continue...


=事件处理=

你可以为结点的指定事件配置回调函数来随意实现一些效果。

完整的事件列表： http://visualjquery.com/ Events 下。

你可以使用 node.preventDefault() 来忽略一个默认的事件响应行为，比如一个 a 标签上有一个链接，而你又不想让它生效。

```
function go(event){
    event.preventDefault();
    $(this).hide("slow");
}

$("#rating").append(ratingMarkup.join(' ')).find("a").click(go);
```

==ready()==

这是一个特别的，并且非常重要的事件。它表示某结点被加载完毕了。在使用 jQuery 时通过对 $(document) 结点的此事件进行函数绑定以执行我们的代码。

```
$(document).ready(function(){
    alert("OK, I have knew all DOM!");
});
```

在使用 $(document).ready() 时要确保你没有为 <body> 的 onload 事件添加过任何代码，否则 $(document).ready() 可能不会被执行。

你可以在你的代码中添加多个 $(document).ready() 函数绑定，它们将会被顺序执行。

一个简单点的写法是：

```
jQuery(function($){
    // code here
});
```

或者更简单：

```
$(function(){
    // code here
});
```

==事件类型==

一般比较常用的事件类型是鼠标的点击一类的。而标准 DHTML 中的事件如 onclick onmouseover 等，在 jQuery 中都有相应的事件对象。

click() 和 click(fn) 激发一个鼠标单击事件和绑定一个鼠标单击事件：

```
$(function(){
    $("#other").click(function(event){alert("here");});
});

$(function(){
    $("#mark").click(function(event){
        $("#other").click();
    });
});
```

对象键盘事件的处理，一般是通过判断事件对象的 which 属性来进行具体的按键判断：

```
$("input").keypress(function (e) {
  if (e.which == 32 || (65 <= e.which && e.which <= 65 + 25)
                    || (97 <= e.which && e.which <= 97 + 25)) {
    var c = String.fromCharCode(e.which);
    $("p").append($("<span/>"))
          .children(":last")
          .append(document.createTextNode(c));
  } else if (e.which == 8) {
    // backspace in IE only be on keydown
    $("p").children(":last").remove();
  }
  $("div").text(e.which);
});
```

其它事件对象的使用，也是这样的。

- dblclick() 和 dblclick(fn) 鼠标双击。
- change() 和 change(fn) 对象改变。
- blur() 和 blur(fn) 失去焦点。
- focus() 和 focus(fn) 获得焦点。
- submit() 和 submit(fn) 表单提交。


==事件绑定==

除了直接在结点上进行事件绑定外，你还可以使用相关函数独立地将结点，事件，回调函数绑定在一起。

===bind(type, data, fn)===

为一个对象的一个事件绑定一个函数：

```
$(function(){
    $("#mark").bind("click", function(e){alert("here!");});
});
```

为一个对象绑定多个事件，多个对象，还可以加上参数：

```
function aClick(event){
    alert(event.data.a);
}
function bClick(){
    alert("second");
}
$(function(){
    $("#mark").bind("click", {"a": "argv"}, aClick);
    $("#mark").bind("click change", bClick);
    $("#other").bind("click", function(){
        $("#mark").trigger("change");
    });
});
```

===one(type, data, fn)===

它的用法和 bind() 是一样的，只是通过 one() 进行的绑定，只会被激活一次。


===trigger(type, data)===

这个函数主要用于激动另一个对象的指定事件。但是，激动另一对象的其它事件，使用像 click() 函数好像是也能做到？不过， trigger() 可以参数激活（当然在相关回调函数定义时也要考虑参数）：

```
$(function(){
    $("#other").one("click", function(e){
        $("#mark").trigger("click", "argvs!!")});
});

$(function(){
    $("#mark").one("click", function(e, other){alert(other);});
});
```

===triggerHandler(type, data)===

与 trigger() 函数使用方法一样。效果上，它会调用相关的函数，但是不会激活事件行为。举例来说，对于 focus 事件， triggerHandler() 会调用与 focus 事件绑定的函数，但是不会使相关对象获得焦点：

```
$("#old").click(function(){
  $("input").trigger("focus");
});
$("#new").click(function(){
  $("input").triggerHandler("focus");
});
$("input").focus(function(){
  $("<span>Focused!</span>").appendTo("body").fadeOut(1000);
});
```

===unbind(type, data)===

取消一个绑定。如果不加任何参数，则一个对象的所有事件绑定都会被取消。

```
function aClick(event){
    alert(event.data.a);
}
function bClick(){
    alert("second");
    $("#mark").unbind("click", bClick);
}
$(function(){
    $("#mark").bind("click", {"a": "argv"}, aClick);
    $("#mark").bind("click change", bClick);
    $("#other").bind("click", function(){
        $("#mark").trigger("change");
    });
});
```

==辅助绑定函数==

===node.hover(fn,fn)===

定义两个函数，第一个在鼠标移入结点时执行，第二个在鼠标移出结点时执行。

```
$("#mark").hover(
function(){
    $(this).append($("<span>***</span>"));
},
function(){
    $(this).find("span:last").remove();
});
```

===node.toggle(fn,fn)===

定义两个函数，鼠标第一次点执行第一个函数，再点执行第二个函数，如此反复。

```
$("#mark").toggle(
function(){
    $(this).append($("<span>***</span>"));
},
function(){
    $(this).find("span:last").remove();
});
```

=AJAX=

先看一个完整的例子：

```
$(function(){
    function go(event){
        event.preventDefault();
        $.get("python.py",
              {'a[]': [$(this).text(),$(this).text()],
               'b': $(this).text()},
              function(data,stat,XHR){
                  $("#rating").text(data);
              },
              'text');
    }

    var ratingMarkup = ["Please rate: "];
    for (var i = 1; i <= 5; i++){
        ratingMarkup[ratingMarkup.length] = '<a href="#">' + i + '</a>';
    };
    $("#rating").append(ratingMarkup.join(' ')).find("a").click(go);
});
```

==发送请求与处理返回结果==

可以使用 $.get() 或 $.post() 两种方法来发送请求。然后定义一个函数，在结果返回时被调用。这两个函数的调用参数是一样的。

```
jQuery.get( url, [ data ], [ callback(data, textStatus, XMLHttpRequest) ], [ dataType ] )
```

: url 请求的 URL ，字符串。
: data 要发送的数据， GET 方法也使用这个。可以是一个字典或一个字符串。
    字典的话，每个成员的数据类型可以是字符串也可以是列表。如果为列表，则为类似 a=1&a=2 这样的发送串。

```
{'a[]': ['1', '2', '3'],
 'b': 'postdata')},
```

: callback 定义的回调函数，它会在服务器返回结果后被调用，被调用时会传入三个参数：
: data 服务器返回的结果。当然，它一定是字符串，但是，对于 JSON 这些格式是可以指定后直接被处理的。
: textStatus 如果成功返回，则此参数为“success”。
: XMLHttpRequest 即当前使用的 XMLHttpRequest 对象。
: dataType指明服务器返回的字符串是什么格式的。比如 text JSON 。


与 $.get() 和 $.post() 两个函数差不多还有 $.getJSON() 和 $.getScript() 它们的使用方法都一样（但最后一个 dataType 参数显然就不要了），前者用于直接获取 JSON 的返回结果，后者获取 JavaScript 脚本的返回结果。

$.get() 和 $.post() 只是对 $.ajax() 这个函数的封装。完全的 AJAX 请求函数是 $.ajax() 。但是，这玩意儿中的参数有点多，现在先不管它。

另外，你可以使用 $.ajaxSetup() 来为之后的 $.ajax() 调用设置默认值，这样你反复请求一个服务器的话，就可以少写一些代码。

```
$.ajaxSetup({
   url: "/xmlhttp/",
   global: false,
   type: "POST"

});
$.ajax({ data: myData });
```

==node.load()==

这个函数也是用于从服务器获取数据的。但是它和前一节介绍的函数有一点不同，就是它会把获取到的数据直接填充到结点中去。

```
.load( url, [ data ], [ complete(responseText, textStatus, XMLHttpRequest) ] )
```

==各种状态的HOOK==

```
$(function(){
    $("#rating").ajaxComplete(function(){
        alert("good");
    });
    $("#rating").click(function(event){
        $(this).load('rate.txt');
    });
});
```


上面的代码，注册了一个函数到 ajaxComplete ，也算是一个事件吧。在 load 完后就会自动执行 ajaxComplete 中注册的那个函数。

- ajaxComplete 传输完成时。
- ajaxError() 传输出现错误时。
- ajaxSend() 请求发出前。
- ajaxStart() 第一个请求发出时。
- ajaxStop() 请求结束时。
- ajaxSuccess() 请求成功完成时



==参数的包装==

jQuery 提供了几个函数用于包装发送到服务器的参数对串。


===$.param()===

```
var s = [{name:"first",value:"Rick"},
         {name:"last",value:"Astley"},
         {name:"job",value:"Rock Star"}];
var r = $.param(s);
alert(r);
alert(decodeURIComponent(r));

// Result:
// first=Rick&last=Astley&job=Rock+Star

var s = {a: {one: 1, two: 2, three: 3},
         b: [1,2,3]};

var r = $.param(s);
alert(r);
alert(decodeURIComponent(r));

// Result:
// a[one]=1&a[two]=2&a[three]=3&b[]=1&b[]=2&b[]=3

var s = {a: {one: 1, two: 2, three: 3},
         b: [1,2,3]};

var r = $.param(s, true);
alert(r);
alert(decodeURIComponent(r));

// Result:
// a=[object+Object]&b=1&b=2&b=3
```

===node.serialize()===

```
<form>
    <div><input type="text" name="a" value="1" id="a" /></div>
    <div><input type="text" name="b" value="2" id="b" /></div>
    <div><input type="hidden" name="c" value="3" id="c" /></div>
    <div>
        <textarea name="d" rows="8" cols="40">4</textarea>
    </div>
    <div><select name="e">
            <option value="5" selected="selected">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
    </select></div>
    <div>
        <input type="checkbox" name="f" value="8" id="f" />
    </div>
    <div>
        <input type="submit" name="g" value="Submit" id="g" />
    </div>
</form>
```

如果提交上面这个表单（保持这个状态）：

```
$('form').submit(function() {
    alert($(this).serialize());
    return false;
});

// Result:
// a=1&b=2&c=3&d=4&e=5
```

===node.serializeArray()===

和上面一个函数一样，都是用于包装表单数据的。只是，上面一个函数的结果是一个发送到服务器的编码串，而这个函数的结果，是一个复合列表：

```
$('form').submit(function() {
    alert($(this).serializeArray());
    return false;
});

// Result:
// [{ name: a value: 1 },
//  { name: b value: 2 },
//  { name: c value: 3 },
//  { name: d value: 4 },
//  { name: e value: 5 }]
```

=动画效果=

==简单的例子==

要实现动画效果，最简单的方法就是直接使用 hide 和 show 这些方法：

```
$("#control").toggle(
    function(){
        $("#show").hide("slow");
    },
    function(){
        $("#show").show("fast");
    }
);
```

如果要想定制效果，就需要使用一些“原始”点的函数了，比如直接使用 animate ：

```
$("#control").toggle(
    function(){
        $("#show").animate({height: "hide", opacity: "hide"}, "slow");
    },
    function(){
        $("#show").animate({height: "show", opacity: "show"}, "slow");
    }
);
```

==常用的预定制效果函数==

===渐隐效果的 fadeIn() 和 fadeOut()===

两个函数的使用方法与参数列是一样的：

```
fadeIn([duration], [callback])
```

: duration 动画效果的持续时间，单位是毫秒。
    这个参数的默认值是 400 你也可以写上 null 。一般对于这种表示时间长短的参数，有两个“常量”可以使用， slow 和 fast 。前者是 600 ，后者是 200 。
: callback
    当动画效果完成时会被调用的函数。


===渐隐效果的 fadeTo()===

```
$(function(){
    $("#control").toggle(
        function(){
            $("#show").fadeTo(1000, 0.5, function(){alert("你看不到我");});
        },
        function(){
            $("#show").fadeTo(1000, 1, function(){alert("我回来了");});
        }
    );
});
```


这个函数也可以实现渐隐效果，它还可以让你自定义透明度。不过，你最好不要把它和上面两个函数混用。

```
fadeTo(duration, opactity, [callback])
```

: duration 同上，动画效果的持续时间。
: opactity 动画结束时的透明度，（0 到 1 之间的数）。
: callback 动画结束时会被调用的函数。


===展开效果的 slideUp() 和 slideDown()===

两个函数的使用方法与参数列是一样的：

```
slideUp([duration], [callback])
```

: duration 动画效果的持续时间，单位是毫秒。
    这个参数的默认值是 400 你也可以写上 null 。一般对于这种表示时间长短的参数，有两个“常量”可以使用， slow 和 fast 。前者是 600 ，后者是 200 。
: callback
    当动画效果完成时会被调用的函数。


===展开效果的 slideToggle()===

这个函数的行为，就像是自动实现了上面两个函数的转换。

```
$(function(){
    $("#control").click(
        function(){
            $("#show").slideToggle(1000, function(){alert("我回来了");});
        }
    );
});
```

使用方法与上面两个是一样的：

```
slideToggle([duration], [callback])
```

: duration 动画效果的持续时间，单位是毫秒。
    这个参数的默认值是 400 你也可以写上 null 。一般对于这种表示时间长短的参数，有两个“常量”可以使用， slow 和 fast 。前者是 600 ，后者是 200 。
: callback
    当动画效果完成时会被调用的函数。


===伸缩效果的 hide() 和 show()===

两个函数的使用方法与参数列是一样的：

```
hide([duration], [callback])
```

: duration 动画效果的持续时间，单位是毫秒。
    这个参数的默认值是 400 你也可以写上 null 。一般对于这种表示时间长短的参数，有两个“常量”可以使用， slow 和 fast 。前者是 600 ，后者是 200 。
: callback 当动画效果完成时会被调用的函数。
