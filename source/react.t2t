React 学习笔记
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/react.html
%!format: !email
%%toc




# React 长什么样 #

*React* 是 facebook 开源出来的一套前端方案，官网在 https://reactjs.org 。

先看一个简单的样子：

```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
</head>
<body>
  <h1>Hello</h1>
  <div id="place"></div>
  <script type="text/javascript">
    var attribute = {
      className: 'text',
      style: {color: 'red'},
      id: 'me',
      href: 'http://' + 's.zys.me'
    };
    var inner = React.createElement('a', attribute, 'React');
    var instance = React.createElement('h1', null, '字符串在中间', inner);
    ReactDOM.render(instance, $('#place')[0]);
  </script>
</body>
</html>
```

从上面可以看出，它的使用其实跟其它很多框架的方式差不多，即，找到一个 DOM 节点，然后在这个节点上做事，类似 jQuery 的 ``$(dom).xxx({})`` 。

在 ``React.createElement`` 中，第一个参数是标签名，第二个是 *config* ，其中包括了节点属性（``class`` 因为关键词问题改用 ``className``） ，第三个及以后，是子级节点，或者说子级元素。

上面两个 ``createElement`` 得到的最终结果，是：

```html
<h1>
    字符串在中间
    <a class="text" style="color: red" id="me" href="http://s.zys.me">React</a>
</h1>
```

当然，这里的重点，不是 ``React.createElement`` ，而是它返回的那个 ``instance`` ，事实上，从源码 https://unpkg.com/react@16.2.0/umd/react.development.js 中看的话，可以看出它返回的是一个 ``ReactElement`` ，这个 ``ReactElement`` 就是整个 *React* 体系于众不同的地方，否则它直接返回一个 DOM Element 就好了。

最后一行的 ``ReactDOM.render`` 就是处理 ``ReactElement`` 的， ``ReactDOM`` 的源码在 https://unpkg.com/react-dom@16.2.0/umd/react-dom.development.js ， 这个东西自己实现了一套挂节点的树结构（所谓的 *Virtual DOM*），中间隔了一层再去处理真实的 DOM 渲染。这么做的好处是，因为自己有一套完整的树结构的，所以，可以在上面实现很多在原始 DOM 结构上不能做，或者不方便做的事。比如，异构渲染之类的。当然，局限的地方也很明显，本质上还是“节点”，其实没有一个往上的抽象，暴露的细节还是很多的，这种情况下，东西可以做得比较细，但是付出的成本也比较大，我是这样预测的。


# ReactElement 的定义 #

最开始，已经简单演示了针对像 ``a`` ``h1`` 这类原生 DOM 元素的 ``ReactElement`` 定义， 自然，“能接受一个确定值的地方也应该可以接受一个函数”是 js 的一个惯例吧：

```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
</head>
<body>
  <div></div>
  <script type="text/javascript">
    function Component(props) {
      if(props.tag === 'h1') {
        return React.createElement('h1', null, '大标题');
      } else {
        return React.createElement('span', null, '普通文本');
      }
    }
    var instance = React.createElement(Component, {tag: 'h1'});
    ReactDOM.render(instance, $('div')[0]);
  </script>
</body>
</html>
```


上面代码的过程，大概是：

- ``React.createElement(type, config, children)`` 返回 ``ReactElement()`` 。
- ``ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props)`` ，上面 ``config`` 的一些东西，会补为这里的几个参数，及 ``props`` 里的东西。
- ``ReactElement()`` 的调用会返回一个 ``element`` ，这是一个比较单纯的结构体，里面会有 ``type`` ``key`` ``ref`` ``props`` ``_owner`` ``$$typeof`` 等内容。
- ``ReactDOM.render(element, container, callback)`` 是对 ``renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback)`` 的调用， ``element`` 也转为 ``children`` 的统一概念了。
- 然后是到 ``DOMRender`` （从 ``reactReconciler`` 来） 的 ``updateContainer(element, container, parentComponent, callback)`` ，最外层的调用， ``container`` 就是一个 ``newRoot`` ，前面的 ``children`` 概念这里又变成 ``element`` 了。
- 上面会处理一下 ``container`` ，接着到 ``scheduleTopLevelUpdate(current, element, callback)`` ， ``current`` 是从 ``container`` 里取的。
- ``scheduleTopLevelUpdate`` 是会作 ``scheduleWork(current, expirationTime)`` ，应该是处理一些同步的事。还有 构造一个 ``update`` 的结构体，然后  ``insertUpdateIntoFiber(current, update)`` ， ``element`` 被放到 ``update`` 中的 ``partialState: { element: element }`` 。
- ``insertUpdateIntoFiber(fiber, update)`` ， 新的 ``element`` 在 ``update`` 中，而 ``fiber`` 是 ``container`` 的范畴。这里只是处理“两个队列”的状态，干活的还是在 ``scheduleWork()`` 中。
- 这个地方开始， ``current`` 和 ``element`` 就分开了，``current`` 继续进入 ``scheduleWork(fiber, expirationTime)`` 进行下一步处理。而 ``element`` 只在 ``insertUpdateIntoFiber`` 中更新于队列状态。
- ``scheduleWork()`` 里实际上会用 ``scheduleWorkImpl(fiber, expirationTime, isErrorRecovery)`` ，这里开始迭代 ``fiber`` ，离真实的节点创建还有一半的路要走吧，中间又各种处理，最后 ``createInstance()`` 会创建真实的节点。


反正，我从源码中找了一长串，还是没搞明白 ``createElement()`` 第一个参数的 ``type`` 可以是，应该是一个什么东西。

从官方的文档来看 https://reactjs.org/docs/react-api.html#createelement ，这个 ``type`` 可以是三类东西：

- 原生类节点，的标签字符串，比如 ``div`` ， ``span`` 。
- ``React component`` ， React 组件，后面单独说。
- ``React fragment`` ，这好像是 v16.2.0 加入的新机制，简单来说它使 React 可以支持直接渲染“一串”节点，而之前，只能直接渲染“一个”节点，如果是一串的需求，那么在外面需要包一个节点。我理解大概就是下面这个样子吧：


```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
</head>
<body>
  <div></div>
  <script type="text/javascript">
    function Component(props) {
      return ['1', React.createElement('h1', null, props.text)];
    }
    var instance = React.createElement(Component, {text: '啊啊啊'});
    ReactDOM.render(instance, $('div')[0]);
  </script>
</body>
</html>
```



