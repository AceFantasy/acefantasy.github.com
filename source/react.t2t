React 学习笔记
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/react.html
%!format: !email
%%toc




# React 长什么样 #

*React* 是 facebook 开源出来的一套前端方案，官网在 https://reactjs.org 。

先看一个简单的样子：

```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
</head>
<body>
  <h1>Hello</h1>
  <div id="place"></div>
  <script type="text/javascript">
    var attribute = {
      className: 'text',
      style: {color: 'red'},
      id: 'me',
      href: 'http://' + 's.zys.me'
    };
    var inner = React.createElement('a', attribute, 'React');
    var instance = React.createElement('h1', null, '字符串在中间', inner);
    ReactDOM.render(instance, $('#place')[0]);
  </script>
</body>
</html>
```

从上面可以看出，它的使用其实跟其它很多框架的方式差不多，即，找到一个 DOM 节点，然后在这个节点上做事，类似 jQuery 的 ``$(dom).xxx({})`` 。

在 ``React.createElement`` 中，第一个参数是标签名，第二个是 *config* ，其中包括了节点属性（``class`` 因为关键词问题改用 ``className``） ，第三个及以后，是子级节点，或者说子级元素。

上面两个 ``createElement`` 得到的最终结果，是：

```html
<h1>
    字符串在中间
    <a class="text" style="color: red" id="me" href="http://s.zys.me">React</a>
</h1>
```

当然，这里的重点，不是 ``React.createElement`` ，而是它返回的那个 ``instance`` ，事实上，从源码 https://unpkg.com/react@16.2.0/umd/react.development.js 中看的话，可以看出它返回的是一个 ``ReactElement`` ，这个 ``ReactElement`` 就是整个 *React* 体系于众不同的地方，否则它直接返回一个 DOM Element 就好了。

最后一行的 ``ReactDOM.render`` 就是处理 ``ReactElement`` 的， ``ReactDOM`` 的源码在 https://unpkg.com/react-dom@16.2.0/umd/react-dom.development.js ， 这个东西自己实现了一套挂节点的树结构（所谓的 *Virtual DOM*），中间隔了一层再去处理真实的 DOM 渲染。这么做的好处是，因为自己有一套完整的树结构的，所以，可以在上面实现很多在原始 DOM 结构上不能做，或者不方便做的事。比如，异构渲染之类的。当然，局限的地方也很明显，本质上还是“节点”，其实没有一个往上的抽象，暴露的细节还是很多的，这种情况下，东西可以做得比较细，但是付出的成本也比较大，我是这样预测的。


# ReactElement 的定义 #

最开始，已经简单演示了针对像 ``a`` ``h1`` 这类原生 DOM 元素的 ``ReactElement`` 定义， 自然，“能接受一个确定值的地方也应该可以接受一个函数”是 js 的一个惯例吧：

```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
</head>
<body>
  <div></div>
  <script type="text/javascript">
    function Component(props) {
      if(props.tag === 'h1') {
        return React.createElement('h1', null, '大标题');
      } else {
        return React.createElement('span', null, '普通文本');
      }
    }
    var instance = React.createElement(Component, {tag: 'h1'});
    ReactDOM.render(instance, $('div')[0]);
  </script>
</body>
</html>
```


上面代码的过程，大概是：

- ``React.createElement(type, config, children)`` 返回 ``ReactElement()`` 。
- ``ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props)`` ，上面 ``config`` 的一些东西，会补为这里的几个参数，及 ``props`` 里的东西。
- ``ReactElement()`` 的调用会返回一个 ``element`` ，这是一个比较单纯的结构体，里面会有 ``type`` ``key`` ``ref`` ``props`` ``_owner`` ``$$typeof`` 等内容。
- ``ReactDOM.render(element, container, callback)`` 是对 ``renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback)`` 的调用， ``element`` 也转为 ``children`` 的统一概念了。
- 然后是到 ``DOMRender`` （从 ``reactReconciler`` 来） 的 ``updateContainer(element, container, parentComponent, callback)`` ，最外层的调用， ``container`` 就是一个 ``newRoot`` ，前面的 ``children`` 概念这里又变成 ``element`` 了。
- 上面会处理一下 ``container`` ，接着到 ``scheduleTopLevelUpdate(current, element, callback)`` ， ``current`` 是从 ``container`` 里取的。
- ``scheduleTopLevelUpdate`` 是会作 ``scheduleWork(current, expirationTime)`` ，应该是处理一些同步的事。还有 构造一个 ``update`` 的结构体，然后  ``insertUpdateIntoFiber(current, update)`` ， ``element`` 被放到 ``update`` 中的 ``partialState: { element: element }`` 。
- ``insertUpdateIntoFiber(fiber, update)`` ， 新的 ``element`` 在 ``update`` 中，而 ``fiber`` 是 ``container`` 的范畴。这里只是处理“两个队列”的状态，干活的还是在 ``scheduleWork()`` 中。
- 这个地方开始， ``current`` 和 ``element`` 就分开了，``current`` 继续进入 ``scheduleWork(fiber, expirationTime)`` 进行下一步处理。而 ``element`` 只在 ``insertUpdateIntoFiber`` 中更新于队列状态。
- ``scheduleWork()`` 里实际上会用 ``scheduleWorkImpl(fiber, expirationTime, isErrorRecovery)`` ，这里开始迭代 ``fiber`` ，离真实的节点创建还有一半的路要走吧，中间又各种处理，最后 ``createInstance()`` 会创建真实的节点。


反正，我从源码中找了一长串，还是没搞明白 ``createElement()`` 第一个参数的 ``type`` 可以是，应该是一个什么东西。

从官方的文档来看 https://reactjs.org/docs/react-api.html#createelement ，这个 ``type`` 可以是三类东西：

- 原生类节点，的标签字符串，比如 ``div`` ， ``span`` 。
- ``React component`` ， React 组件。
- ``React fragment`` ，这好像是 v16.2.0 加入的新机制，简单来说它使 React 可以支持直接渲染“一串”节点，而之前，只能直接渲染“一个”节点，如果是一串的需求，那么在外面需要包一个节点。我理解大概就是下面这个样子吧：


```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
</head>
<body>
  <div></div>
  <script type="text/javascript">
    function Component(props) {
      return ['1', React.createElement('h1', null, props.text)];
    }
    var instance = React.createElement(Component, {text: '啊啊啊'});
    ReactDOM.render(instance, $('div')[0]);
  </script>
</body>
</html>
```


React 组件有两种类型，一种是简单的“函数式组件”，另一种是复杂点的“类组件”。

函数式组件就是接受 ``props`` ，然后返回一个 ``React element`` ：

```javascript
function Component(props) {
  return React.createElement('h1', null, props.text);
}
```

类组件，是继承 ``React.Component`` ，然后重写一些方法：

```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16.2.0/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16.2.0/umd/react-dom.development.js"></script>
</head>
<body>
  <div></div>
  <script type="text/javascript">
    class MyComponent extends React.Component {
      render(){
        return React.createElement('h1', null, this.props.text);
      }
    }
    var instance = React.createElement(MyComponent, {text: '哈哈'});
    ReactDOM.render(instance, $('div')[0]);
  </script>
</body>
</html>
```


# createElement 的 DSL 方案 JSX #

前面提过，如果你想通过 ``createElement`` 构造一个类似：

```html
<h1>
    字符串在中间
    <a class="text" style="color: red" id="me" href="http://s.zys.me">React</a>
</h1>
```

那么你需要的 js 大概是：

```javascript
var attribute = {
  className: 'text',
  style: {color: 'red'},
  id: 'me',
  href: 'http://' + 's.zys.me'
};
var inner = React.createElement('a', attribute, 'React');
var instance = React.createElement('h1', null, '字符串在中间', inner);
ReactDOM.render(instance, $('#place')[0]);
```

看起来是比较麻烦的，于 React 中引入了一个新的东西，JSX ，即 JavaScript XML ，简单来说，就是 javascript 和 XML  的混写，上面的代码可以写成：

```javascript
var inner = <a className="text" style={ {color: 'red'} } id="me" href={'http://' + 's.zys.me'}>React</a>;
var instance = <h1>字符串在中间 {inner}</h1>;
ReactDOM.render(instance, $('#place')[0]);
```

甚至是：

```javascript
var inner = <a className="text" style={ {color: 'red'} } id="me" href={'http://' + 's.zys.me'}>React</a>;
ReactDOM.render(<h1>字符串在中间 {inner}</h1>, $('#place')[0]);
```

可以看出，比原来直接写 ``createElement`` 的方式要简洁得多， JSX 除了支持直接写 XML 风格的标签，还可以使用 ``{}`` 处理表达式。不过， JSX 并不是浏览器的标准，要让它跑在浏览器，需要在发布前专门编译到纯 js ，平时测试，也可以直接用 *babel* 来跑：

```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
<script crossorigin src="https://unpkg.com/babel-standalone@6.15.0/babel.js"></script>
</head>
<body>
  <h1>Hello</h1>
  <div id="place"></div>
  <script type="text/babel">
    var inner = <a className="text" style={ {color: 'red'} } id="me" href={'http://' + 's.zys.me'}>React</a>;
    ReactDOM.render(<h1>字符串在中间 {inner}</h1>, $('#place')[0]);
  </script>
</body>
</html>
```

注意，上在的 ``script`` 的 ``type`` 写的是 ``text/babel`` 哦。

*babel* 也有命令行的工具，先安装：

```bash
npm install -g babel
npm install -g babel-cli
npm install -g babel-preset-react
```

然后对于一个 ``demo.jsx`` ：

```
var inner = <a className="text" style={ {color: 'red'} } id="me" href={'http://' + 's.zys.me'}>React</a>;
ReactDOM.render(<h1>字符串在中间 {inner}</h1>, $('#place')[0]);
```

可以使用 *babel* 编译它：

```bash
babel --presets=react demo.jsx
```

就可以看到标准的 js 输出了：

```javascript
var inner = React.createElement(
  "a",
  { className: "text", style: { color: 'red' }, id: "me", href: 'http://' + 's.zys.me' },
  "React"
);
ReactDOM.render(React.createElement(
  "h1",
  null,
  "\u5B57\u7B26\u4E32\u5728\u4E2D\u95F4 ",
  inner
), $('#place')[0]);
```

*babel* 默认输出的到标准输出，可以通过 ``-o`` 输出到指定文件。

平时的前端项目，一般把 *babel* 和 *webpack* 结合使用，在构建过程处理 JSX 格式。


**提示一下， JSX 不是模板，它的行为，更像是“宏”。本质，还是 js 代码。**



# 使用 state 处理数据单向绑定 #

前面已经提到过 *props* 了， *props* 一般处理初始化后就不改变的数据，对于一个组件中要变化的数据，需要放在 *state* 中处理，因为 React 专门设计了组件的 ``setState()`` 来维护 *state* （不要直接更改 *state* ，而是使用 ``setState()``） ，同时 ``setState()`` 还处理节点渲染相关的事，通过函数调用，来实现“数据到展现”的单向绑定。

```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
<script crossorigin src="https://unpkg.com/babel-standalone@6.15.0/babel.js"></script>
</head>
<body>
  <div id="place"></div>
  <script type="text/babel">

    class MyComponent extends React.Component {
      constructor(props) {
          super(props);
          this.state = {date: (new Date()).valueOf()};
          setInterval(() => this.setState({date: (new Date()).valueOf()}), 1000);
      }

      render(){
        return <h1>Hello {this.props.name} {this.state.date}</h1>;
      }

    }

    ReactDOM.render(<MyComponent name="哈哈" />, $('#place')[0]);
  </script>
</body>
</html>
```


``setState()`` 也可以接受一个函数，这个函数的参数第一个是当前的 *state* ，另一个是 *props* ：

```javascript
class MyComponent extends React.Component {
  constructor(props) {
      super(props);
      this.state = {date: (new Date()).valueOf()};
      setInterval(() => this.setState((prevState, props) => ({date: prevState.date + 1000})), 1000);
  }

  render(){
    return <h1>Hello {this.props.name} {this.state.date}</h1>;
  }

}

ReactDOM.render(<MyComponent name="哈哈" />, $('#place')[0]);
```


# 事件处理 #


React 自己维护了一个节点状态的树结构，并且，同时也自己实现了一套事件机制，只是这套事件，跟浏览器自身的区别不是很大：


```javascript
class MyComponent extends React.Component {
  constructor(props) {
      super(props);
      this.state = {date: (new Date()).valueOf()};
      setInterval(() => this.setState((prevState, props) => ({date: prevState.date + 1000})), 1000);
  }

  handleClick = () => {
      console.log(this);
  }

  render(){
      return <h1 onClick={this.handleClick}>Hello {this.props.name} {this.state.date}</h1>;
  }

}

ReactDOM.render(<MyComponent name="哈哈" />, $('#place')[0]);
```


注意那个 ``handleClick`` 的写法：

```javascript
handleClick = () => {
    console.log(this);
}
```

如果不用“箭头函数”把 ``this`` 固定住了，那么在使用时就需要显式绑定：

```javascript
handlerClick(){
    console.log(this);
}

render(){
    return <h1 onClick={this.handleClick.bind(this)}>Hello {this.props.name} {this.state.date}</h1>;
}
```

React 自己的事件，是“驼峰式”的名字，比如 ``onClick`` ，而 ``onclick`` 则是浏览器自己的事件了。

其它支持的完整的事件列表，见： https://reactjs.org/docs/events.html


# 列表与 key #


```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
<script crossorigin src="https://unpkg.com/babel-standalone@6.15.0/babel.js"></script>
</head>
<body>
  <div id="place"></div>
  <script type="text/babel">

    class MyComponent extends React.Component {
      constructor(props) {
          super(props);
          this.state = {itemList: [{name: 'abc', id: 'a'}, {name: 'oiii', id: 'b'}] };
      }

      handleClick(o){
        return (e) => {
          console.log(o);
        }
      }

      render(){
        return <div>
          {this.state.itemList.map( (o) => (<div key={o.id} onClick={this.handleClick(o)}>{o.name}</div>) ) }
          </div>
      }

    }

    ReactDOM.render(<MyComponent name="哈哈" />, $('#place')[0]);
  </script>
</body>
</html>
```

对于列表的渲染， React 要求节点上需要添加 ``key`` 属性，否则，会报 *warn* （是的，不会报错）。如果没有明确的 id 之类的标识，可以使用序列的索引值 *index* 。这个 ``key`` 属性的作用， React 会用于标识节点，以便在数据变更时，对应地可以追踪到节点的变更情况。



# 组件的各状态 Hook （生命周期） #

对于一个 React 组件，准备说，“类组件”，它在渲染及销毁过程中，每个状态转换时， React 都预留了相关的 Hook 函数，这些函数，一共 10 个，可以分成 4 类：

- 渲染时
    - ``constructor(props)``
    - ``componentWillMount()``
    - ``render()``
    - ``componentDidMount()`` ，从这里开始， ``setState()`` 会触发重新的 ``render()`` 。
- 修改时
    - ``componentWillReceiveProps(nextProps)`` ， *props* 改变时触发，可以由于父组件的变化引起。 ``setState()`` 一般不会触发这个过程。
    - ``shouldComponentUpdate(nextProps, nextState)`` ，如果返回 ``false`` ，则使 React “尽量” 不要重新渲染组件，注意，只是 “尽量” 而已。如果渲染上有性能问题，则应该考虑其它解决方案。
    - ``componentWillUpdate(nextProps, nextState)`` ，上面的 ``shouldComponentUpdate()`` 如果返回 ``false`` ，则这个过程一定不会触发，现时，第一次初始化不会触发这个过程。
    - ``render()``
    - ``componentDidUpdate(prevProps, prevState)`` ，第一次初始化不会触发这个过程。
- 销毁时
    - ``componentWillUnmount()``
- 出错时
    - ``componentDidCatch(error, info)``



除了上面讲的过程 Hook 函数，及前面用过的 ``setState()`` ，组件还有一个 ``forceUpdate(callback)`` 方法，它的调用可以触发 ``render()`` ，并且跳过 ``shouldComponentUpdate()`` 。


另外，在“类”层面，有两个属性， ``defaultProps`` 用于定义默认的 *props* ， ``displayName`` ，用于定义调试时显示的名字。


试试各个过程的表现吧：

```html
<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title>React</title>
<script crossorigin src="https://s.zys.me/js/jq/jquery.min.js"></script>
<script crossorigin src="https://s.zys.me/js/react/react.min.js"></script>
<script crossorigin src="https://s.zys.me/js/react/react-dom.min.js"></script>
<script crossorigin src="https://s.zys.me/js/react/babel.min.js"></script>
</head>
<body>
  <div></div>
  <script type="text/babel">
    class MyComponent extends React.Component {
      constructor(props){
        super(props);
        this.state = {name: '初始化'};
        let that = this;
        setTimeout(function(){
          console.log('2s go ...');
          that.setState({name: '修改了的'});
        }, 2000);
        console.log('constructor');
      }

      componentWillMount(){
        console.log('componentWillMount');
      }

      componentDidMount(){
        console.log('componentDidMount');
      }

      componentWillReceiveProps(nextProps){
        console.log('componentWillReceiveProps');
      }

      shouldComponentUpdate(nextProps, nextState){
        console.log('shouldComponentUpdate');
        return true;
      }

      componentWillUpdate(nextProps, nextSate){
        console.log('componentWillUpdate');
      }

      componentDidUpdate(prevProps, prevState){
        console.log('componentDidUpdate');
      }

      componentWillUnmount(){
        console.log('componentWillUnmount');
      }

      componentDidCatch(error, info){
        console.log('componentDidCatch');
      }

      render(){
        console.log('render');
        if(this.props.error){throw Error()};
        return <h1>{this.state.name}</h1>;
      }

    }
    ReactDOM.render(<MyComponent />, $('div')[0]);

    setTimeout(function(){
      console.log('5s go ...');
      ReactDOM.render(<MyComponent />, $('div')[0]);
    }, 5000);

    setTimeout(function(){
      console.log('10s go ...');
      ReactDOM.render(null, $('div')[0]);
    }, 10000);

  </script>
</body>
</html>
```

上面的代码会输出：

```text
constructor
componentWillMount
render
componentDidMount
2s go ...
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate
5s go ...
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate
10s go ...
componentWillUnmount
```


